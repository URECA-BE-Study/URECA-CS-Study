# 페이지 교체 알고리즘 (Page Replacement Algorithm)

운영체제에서 **페이지 교체 알고리즘**은 페이지 부재(Page Fault)를 최소화하여 시스템의 성능을 높이기 위한 핵심 전략입니다.

---

## 1. 페이지 교체란?

운영체제는 **페이징(Paging)** 기법을 통해 프로세스의 메모리를 관리합니다.  
필요한 페이지가 메모리에 없다면 **페이지 부재(Page Fault)**가 발생하며, 디스크에서 해당 페이지를 메모리로 로드합니다.

하지만 메모리가 가득 찬 경우, 기존 페이지 중 하나를 디스크로 내보내야 합니다.  
이때 어떤 페이지를 제거할 것인지 결정하는 것이 **페이지 교체 알고리즘**입니다.

- **Victim Page**: 제거 대상 페이지
- **목표**: 앞으로 사용할 가능성이 가장 낮은 페이지를 선택해 **Page Fault를 최소화**

---

## 2. 페이지 교체 알고리즘 종류

| 분류 | 알고리즘 | 설명 |
|------|----------|------|
| 간단한 방식 | **Random** | 무작위로 페이지를 교체 |
| | **FIFO** | 가장 먼저 들어온 페이지를 교체 |
| 이론적 최적 | **OPT (Optimal)** | 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체 |
| 최적 근접 | **LRU** | 최근 가장 오랫동안 사용되지 않은 페이지 |
| | **LFU** | 참조 횟수가 가장 적은 페이지 |
| | **NUR (NRU)** | 최근 사용되지 않은 페이지 |
| FIFO 변형 | **SCR** | FIFO에 2차 기회를 주는 방식 |
| | **Clock** | SCR을 원형 큐로 개선한 방식 |

---

## 3. 알고리즘 상세 설명

### 🔹 OPT (Optimal Replacement)
![image](https://github.com/user-attachments/assets/8f480b0b-4c18-4a76-8048-b35aa7fd2e78)

- **가장 이상적인 알고리즘**
- 미래에 가장 오랫동안 사용되지 않을 페이지를 교체
- 구현 불가능 → **성능 평가 기준**으로 사용됨

  **동작 방식**
1. 앞으로의 페이지 참조 순서를 모두 알고 있다고 가정한다.
2. 현재 메모리에 있는 페이지들 중에서 **가장 나중에 참조될 페이지**를 victim page로 선택한다.
3. 해당 victim page를 교체하고, 새로운 페이지를 적재한다.

예시:  
페이지 참조 순서가 `A B C D B A C`이고, 프레임이 3개일 경우  `A, B, C`가 적재된 상태에서 `D` 요청 시, 앞으로 가장 늦게 참조될 `A`를 제거.

**특징**
- Page Fault 수 최저
- Belady’s Anomaly 발생 ❌

---

### 🔹 FIFO (First-In First-Out)
![image](https://github.com/user-attachments/assets/636f3338-8eb7-498b-aeae-8ed926413432)

- 가장 먼저 들어온 페이지를 교체
- 큐(Queue) 자료구조로 간단하게 구현 가능
  
**동작 방식**
1. 페이지가 메모리에 올라오면 **큐의 맨 뒤에 삽입**한다.
2. 페이지가 요청되었을 때,
   - 메모리에 존재하면 그대로 사용 (Page Hit)
   - 존재하지 않으면 큐의 **맨 앞에 있는 페이지를 제거**하고, 새로운 페이지를 뒤에 추가 (Page Fault)

예시:  
페이지가 `A → B → C → D` 순으로 들어오면 `A`가 가장 먼저 들어왔으므로, `D` 요청 시 `A`가 제거됨.

#### 단점

- **무조건 오래된 페이지**를 대상 페이지로 선정하기 때문에 자주 사용되는 페이지도 교체되는 문제가 있음
- 이로 인해 성능이 저하될 수 있음
- 이를 보완하기 위해 '2차 기회 페이지 교체 알고리즘(SCR)'이 등장함

---

#### Belady's Anomaly (벨라디의 이상현상)

- 페이지 프레임의 수가 **증가했음에도 불구하고** 페이지 부재(Page Fault) 횟수가 **오히려 증가하는 현상**
- 직관적으로는 프레임 수가 많아지면 page fault가 줄어들어야 하지만, **FIFO 알고리즘에서는 반대로 증가**할 수 있음

**예시**
- 동일한 페이지 참조 순서에서,
  - **페이지 프레임 수가 3개일 때보다**
  - **4개일 때 page fault가 더 많이 발생**

이 현상은 **FIFO와 같은 단순 교체 알고리즘에서만 발생**하며, **LRU, OPT와 같은 알고리즘에서는 발생하지 않음**


---

### 🔹 LRU (Least Recently Used)
![image](https://github.com/user-attachments/assets/d6213dfb-66e0-47cd-be74-a6e4a37fe82a)

- **가장 오래 사용되지 않은 페이지** 교체
- **시간 지역성(Locality of Reference)** 기반

**동작 방식**
1. 각 페이지가 **마지막으로 사용된 시간 또는 순서**를 기록한다.
2. 페이지 요청 시:
   - 이미 메모리에 있으면 해당 시간/순서를 갱신 (Page Hit)
   - 없으면 가장 오래전에 사용된 페이지를 제거하고 새 페이지를 적재 (Page Fault)


## 구현 방법 종류

##### 1. 카운터 방식

- 각 페이지마다 **최근 사용된 시간**을 저장하는 방식
- 페이지가 참조될 때마다 해당 페이지의 시간(또는 순번)을 갱신
- 교체 시점에는 **가장 오래된 시간값을 가진 페이지**를 선택하여 교체

**장점**
- 논리적으로 직관적인 구현

**단점**
- 모든 페이지에 대한 시간 값을 비교해야 하므로 **비교 연산 많음**
- **페이지 테이블 갱신 시 오버헤드 발생**
- **하드웨어 시계 또는 소프트웨어 타이머 필요**


##### 2. 스택 방식

- 참조된 페이지를 **스택의 가장 위로 이동**
- 페이지가 참조되면 스택 내에서 해당 항목을 제거하고 **top에 다시 삽입**
- 스택의 **bottom에는 가장 오랫동안 사용되지 않은 페이지**가 위치

**장점**
- 교체 대상(page) 결정이 빠름 (항상 bottom)

**단점**
- 참조될 때마다 스택 조작 필요 → **오버헤드 발생**
- 구현이 간단하지만 **성능 부담이 큼**

---

## 특징

- **시간 지역성**을 적극 반영
- 페이지가 언제 참조되었는지를 기준으로 교체
- FIFO보다 성능 우수, OPT보다는 낮음
- **Belady’s Anomaly가 발생하지 않음**
- **LFU, NUR보다 구현이 단순하고 안정적**


#### 단점

- **모든 참조에 대해 시간 또는 위치 정보 갱신 필요**
- **오버헤드가 크며, 하드웨어 지원이 요구되기도 함**
  - 예: 카운터, 스택, 큐 등 별도 구조 필요
- **실제 시스템에서는 LRU 근사 알고리즘 사용이 일반적**

---

### 🔹 LFU (Least Frequently Used)
![image](https://github.com/user-attachments/assets/6476d4f4-d813-4402-8743-0b1d31247624)

- **참조 횟수가 가장 적은 페이지** 교체

**구현 방식**
- `Incache-LFU`: 메모리 적재 후 참조 수 기록
- `Perfect-LFU`: 전체 참조 이력 저장

**동작 방식**
1. 각 페이지의 **누적 참조 횟수**를 저장한다.
2. 페이지 요청 시:
   - 존재하면 참조 횟수 증가 (Page Hit)
   - 존재하지 않으면 **참조 횟수가 가장 적은 페이지를 제거**하고 새 페이지 적재 (Page Fault)
3. 참조 횟수가 같은 페이지가 여러 개일 경우 FIFO 또는 LRU로 결정

참고:  
초기에만 많이 사용되고 이후 사용되지 않는 페이지가 계속 남아있는 문제 발생 가능

**장점**
- 장기적 패턴 반영 가능

**단점**
- 낭비되는 메모리 공간이 많음
- 페이지 접근 빈도를 표시하기 위한 추가 공간 필요
- 초기에 한 페이지를 집중적으로 참조하다가 이후에 다시 참조하지 않는 경우 문제가 될 수 있음
- 앞으로 사용하지 않아도 초기에 사용된 참조 횟수가 높아서 메모리에 계속 남아있기 때문

---

### 🔹 NUR = NRU (Not Used Recently)
![image](https://github.com/user-attachments/assets/13e9b6f1-5213-4bf6-b404-bee62378c281)

- 최근 사용되지 않은 페이지를 교체
- **참조 비트 + 변경 비트 (2비트)** 사용

**클래스 분류**

| 클래스 | 참조 비트 | 변경 비트 | 설명 |
|--------|------------|-------------|------|
| 0 | 0 | 0 | 접근 & 변경 없음 (가장 우선순위 높음) |
| 1 | 0 | 1 | 변경만 발생 |
| 2 | 1 | 0 | 접근만 발생 |
| 3 | 1 | 1 | 접근 & 변경 모두 발생 |

**동작 방식**
1. 각 페이지에 **2비트 (참조 비트, 변경 비트)**를 둔다.
   - 참조 비트(R): 읽기/실행 시 1
   - 변경 비트(M): 쓰기 시 1
2. 주기적으로 모든 페이지의 비트를 검사하여 아래 순서로 페이지 선택:
   1. (0,0): 사용도 변경도 없는 페이지
   2. (0,1): 변경만 있었던 페이지
   3. (1,0): 참조만 있었던 페이지
   4. (1,1): 자주 사용 및 변경된 페이지
3. 비트가 모두 (1,1)이라면 → 전체 비트를 (0,0)으로 초기화하고 다시 검사

**장점**
- LRU/LFU 성능에 근접
- **2비트만으로 효율적 구현**

**단점**
- 주기적인 비트 초기화 및 관리 필요
- 하드웨어 지원 또는 소프트웨어 오버헤드 존재

---

## 4. FIFO 변형 알고리즘

### 🔸 SCR (Second-Chance Replacement)
![image](https://github.com/user-attachments/assets/26505d0a-daee-45b0-9775-77157a56aa6d)

- FIFO 알고리즘의 단점을 보완
- **참조 비트가 1인 페이지는 한 번 더 기회를 주고 큐 뒤로 이동**

**동작 방식**
1. FIFO처럼 페이지를 큐에 삽입한다.
2. 페이지를 교체할 때, 큐의 앞에서부터 하나씩 검사한다.
   - 참조 비트가 `0`이면 → 해당 페이지 교체
   - 참조 비트가 `1`이면 → `0`으로 초기화 후 큐의 맨 뒤로 이동시켜 **2차 기회 부여**
3. 반복하여 교체할 페이지를 선정

**특징**
- 자주 사용된 페이지는 다시 뒤로 밀려나며 보호됨
- FIFO보다 성능 ↑
- LRU보다는 성능 ↓

### 🔸 Clock Algorithm
![image](https://github.com/user-attachments/assets/15ee3a4d-8d97-4673-aaf6-f14dbdbc9ee8)

- SCR을 **원형 큐**로 구현한 방식
- **시계 바늘처럼 포인터가 순환**하면서 각 페이지의 참조 비트를 검사

**동작 방식**
1. 페이지들을 원형 큐에 배치하고, 포인터를 둔다.
2. 페이지 요청 시:
   - 참조 비트가 `1`인 경우 → `0`으로 초기화 후 포인터를 다음 페이지로 이동
   - 참조 비트가 `0`인 경우 → 해당 페이지 교체
3. 포인터가 한 바퀴 돌 때까지 대상 페이지를 찾지 못하면 계속 반복

구현:
- 각 페이지에 참조 비트 1개만 필요
- FIFO + LRU의 장점을 결합한 효율적인 방식

**장점**
- **추가 공간 요구 적음** (참조 비트 1개 + 포인터만 필요)
- **LRU에 근접한 성능**
- **간단한 하드웨어 지원으로도 구현 가능**

**단점**
- 구현이 **비교적 복잡**
- 포인터 회전으로 인한 계산량 증가
- 정확한 "가장 오래된 페이지" 판단은 불가능

---

## 5. 성능 비교

| 알고리즘 | 구현 난이도 | 성능 | 메모리 추가 요구 |
|----------|--------------|--------|--------------------|
| **Random** | 매우 쉬움 | 낮음 | 없음 |
| **FIFO** | 쉬움 | 낮음 | 큐 |
| **OPT (Optimal)** | 불가능 | 최고 | 없음 (이론적) |
| **LRU** | 보통 | 높음 | 참조 시간 / 스택 등 |
| **LFU** | 어려움 | 높음 | 참조 카운터 |
| **NUR (NRU)** | 쉬움 | 높음 | 참조 비트 + 변경 비트 (2비트) |
| **SCR** | 보통 | 중간 | 참조 비트 + 큐 |
| **Clock** | 보통 | 중간 | 참조 비트 + 포인터 |

---

## 6. 참고 사항

- **현대 운영체제의 적용 방식**
  - Linux, Windows, macOS 등은 **Clock 알고리즘과 LRU를 혼합**하여 사용
  - 하드웨어 부담을 줄이고, 성능을 확보하는 **하이브리드 방식** 채택

---

## Ref
https://github.com/jmxx219/CS-Study/blob/main/operating-system/%ED%8E%98%EC%9D%B4%EC%A7%80%20%EA%B5%90%EC%B2%B4%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.md

