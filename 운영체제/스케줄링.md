
## 1. 스케줄링의 목적

- **공평성** : 모든 프로세스가 공평하게 실행되어야 한다. 특정 프로세스가 실행되지 않는 경우가 없도록 해야 한다.
- **효율성** : 자원을 효율적으로 사용하여 자원이 사용되지 않는 시간이 없도록 해야 한다.
- **안정성** : 우선순위를 고려하여 높은 우선순위의 프로세스를 먼저 처리하도록 해야 한다.
- **반응 시간 보장** : 프로세스가 오랜 시간 응답이 없으면 사용자는 시스템이 멈춘 것으로 보기 때문에 일정 시간 내에 응답할 수 있도록 해야 한다.
- **무한 연기 방지** : 특정 프로세스에 대한 처리가 무한히 연기되지 않도록 해야 한다.

<br><br>

## 2. 스케줄링의 단계

### 1) 장기 스케줄링 (long-term scheduling) 
- 잡 스케줄링(job scheduling) 또는 승인 스케줄링(admission scheduling)이라고도 하며, 준비 큐에 어떤 프로세스를 넣을지 결정해 메모리에 올라가는 프로세스 수를 조정한다. 
- 현대 운영체제에서는 시분할 시스템을 사용하기 때문에 대부분 사용하지 않는다. 

### 2) 중기 스케줄링 (mid-term scheduling)
- 메모리에 로드된 프로세스 수를 동적으로 조절한다.
- 메모리에 프로세스가 많이 로드되면 swap out해서 일부 프로세스를 통째로 저장한다. swap out된 프로세스는 중단 상태(suspended)가 된다. 중단 상태는 준비 상태에서 swap out된 '중단된 준비 상태'와 대기 상태에서 swap out된 '중단된 대기 상태'로 구분된다.


> ✔️ **스왑 아웃과 스왑 인**
> - **스왑 아웃(swap out)** : 프로세스가 실행되려면 메모리에 로드되어야 한다. 그런데 메모리 공간보다 많은 프로세스가 로드되는 경우가 있는데 이럴 때 중기 스케줄러가 이벤트 발생을 기다리고 있는 프로세스를 통째로 저장 공간(ex. SSD)으로 옮겨 저장하는 것을 말함.
> - **스왑 인(swqp in)** : 스왑 아웃한 프로세스에서 이벤트 요청이 오면 해당 프로세스를 다시 통째로 메모리에 로드하는 것을 말함.
> - **스와핑(swapping)** : 스왑 아웃과 스왑 인처럼 프로세스를 통째로 메모리 영역과 저장 공간으로 옮기는 것을 말함. 스와핑하면 메모리 공간보다 많은 프로세스를 실행할 수 있다는 장점이 있음.


### 3) 단기 스케줄링 (short-term scheduling)
- Ready Queue에 있는 대기 상태 프로세스 중 어떤 프로세스를 다음으로 실행할지 스케줄링 알고리즘으로 결정한다. 즉, 어떤 프로세스를 dispatch할지 결정하는데, 이를 CPU 스케줄링이라고도 한다. 

![스케줄러 관점에서 표현한 프로세스 스케줄링](https://velog.velcdn.com/images/hayong39/post/01acac7c-b55b-423a-9256-0ceac3e8adbc/image.jpg)

![스케줄링 단계](https://velog.velcdn.com/images/hayong39/post/7ced1bdb-efe1-4496-9fcb-029967a51aa5/image.jpg)

**[스케줄러 관점에서 스케줄링]**

1. 스케줄러가 준비 큐에 있는 프로세스 중 하나를 선택해 CPU에 디스패치한다. (스케줄링 알고리즘 이용)

2. CPU에서 프로세스를 실행한다. 이때 프로세스는 실행 상태다.
	- 프로세스 수행이 완료되면 프로세스를 종료한다.
	- 일정 시간을 초과하면 인터럽트가 발생해 프로세스가 준비 큐로 들어가고 준비 상태가 된다.
	- 입출력 요청이 들어오면 인터럽트가 발생한다. 이때 프로세스는 대기 큐로 들어가서 대기 상태가 된다. 입출력이 완료되면 프로세스는 준비 큐로 들어간다.

3. fork()가 호출되면 자식 프로세스가 생성되고, 자식 프로세스는 준비 큐로 들어간다.

<br><br>

## 3. CPU 스케줄링이란?

CPU 스케줄링은 **Ready Queue에 대기 중인 프로세스 중 어떤 프로세스에게 CPU를 할당한 것인지를 결정하는 작업**을 의미한다. 컴퓨터 시스템에는 **I/O bound job**과 **CPU bound job**이 섞여있기 때문에, 스케줄링이 필요하다.

CPU 스케줄링에는 크게 2가지 이슈가 있다.
첫째, 당장 어떤 프로세스에게 CPU를 할당할 것인지 결정해야 한다. 
둘째, CPU를 할당한 후에는 CPU를 특정 시점에 다시 회수할 것인지, 아니면 해당 작업이 끝날때까지 기다릴 것인지도 결정해야 한다. 

> ✔️ **CPU burst, I/O burst**
> **CPU burst** :  프로그램을 실행될 때 CPU에서 기계어 명령을 처리하는 단계를 의미한다. 
> **I/O burst** : 프로그램이 실행 중 I/O 작업을 수행하는 단계를 의미한다. 
> 모든 프로그램은 CPU burst와 I/O burst를 번갈아가며 수행하는 구조를 가진다. 
> 사용자와의 상호작용이 자주 있을 경우에는 I/O burst가 빈번하게 생길 것이고, 짧은 CPU burst를 가지게 될 것이다. 반대로 오랜 시간 연산이 필요한 작업들의 경우, 긴 CPU Burst 이후 가끔 I/O Burst가 발생하는 구조를 가진다.

> ✔️ **CPU bound job, I/O bound job**
> CPU burst가 긴 프로그램은 **CPU bound job**이라고 하고, CPU burst가 짧은 프로그램을 **I/O bound job**이라고 한다. 
> 여기서 CPU 스케줄링이 필요한 이유가 대두된다. **CPU bound job은 빈도도 낮으며 한 번 CPU를 쓰면 오래 쓴다. 그러나 I/O bound job의 경우 CPU를 짧게 여러 번 사용한다.** 따라서 두 job들이 맞물려 있다면 I/O bound job을 적절히 수행할 수 없게 되며 사용자가 답답함을 느끼게 될 것이다. 따라서 적절한 관리가 필요하다.
> 그러나 무조건 공평하게 CPU를 분배한다고 해결되는 것은 아니다. **사용자의 입장에서는 무조건 공평한 것 보다는 사용자와 가까운, 즉, Interactive job에게 더 우선적으로 스케줄링을 해주는 것이 좋을 것**이다. 그러니까 **Interactive job이 너무 오래 기다리지 않게 하도록 하는 것, 이것이 바로 CPU 스케줄링의 핵심**이다.

> ✔️ **CPU Scheduler & Dispatcher**
> **CPU scheduler** : 누구에게 CPU를 줄 지 결정한다. 운영체제 커널 내부에 있는 스케줄링 코드 부분을 말한다. 
> **Dispatcher** : CPU를 누구에게 줄 지 결정했다면 그 프로세스에게 넘겨주는 운영체제 커널 코드를 말한다. (문맥 교환)

CPU 스케줄링이 필요한 경우는 프로세스에게 다음과 같은 상태 변화가 있는 경우이다. 

1. Running -> Blocked (ex. I/O 요청하는 시스템 콜)
2. Running -> Ready (ex. 할당시간만료로 timer interrupt)
3. Blocked -> Ready (ex. I/O 완료 후 인터럽트)
4. Terminate

여기서 1과 4에서의 스케줄링은 **nonpreemptive(자진 반납)**, 2와 3에서의 스케줄링은 **preemptive(강제로 빼앗는) 스케줄링**이라고 한다.  

<br><br>

## 4.  CPU 스케줄링 성능 척도

- **CPU 사용률(CPU Utilization)**
	- 전체 시간 중 CPU가 놀지 않고 일한 시간의 비율
- **처리량 (Throughput)**
	- 단위시간(time unit)당 실행한 프로세스 수
- **응답 시간 (Response Time)**
	- 프로세스에 요청이 발생했을 때 응답까지 걸리는 시간
	- 대기열에서 처음으로 CPU를 얻을 때까지 걸린 시간
- **반환 시간 (Turnaround time)**
	- 프로세스가 로드된 이후부터 종료될 때까지 걸리는 시간
	- ready queue 대기 시간 + CPU 실행 시간 +  I/O 작업시간
- **대기 시간 (Waiting time)**
	- 프로세스가 ready queue에서 대기하는 시간의 총합

>💡 시스템 입장의 성능척도(CPU 사용률, 처리량)는 늘리고, 프로그램 입장의 성능척도(응답 시간, 반환 시간, 대기 시간)는 줄이는 것이 좋음

<br><br>

## 5. 스케줄링 알고리즘
### 1) 비선점형 스케줄링 (non-preemptive scheduling)

실행 중인 프로세스가 종료될 때까지 다른 프로세스를 실행할 수 없음을 의미한다. 

### 1-1 ) FCFS(First Come First Served) 스케줄링

📌 **설명**
 ready queue에 먼저 들어온 프로세스가 우선순위를 갖는 알고리즘이다. Batch system(일괄처리 시스템)에 적합하고, interactive system(대화형 시스템)에 부적합하다.

📌 **장점**
- 스케줄링이 단순
	- 선입선출(FIFO) Queue로 쉽게 관리 가능
- 효율적인 자원 사용가능
	- 불필요한 스케줄링 오버헤드가 없음

📌 **단점**
- **Convoy 효과** 발생
	실행시간이 긴 프로세스가 먼저 도착해서 CPU를 오래 쓰는 바람에 뒤에 있는 짧은 프로세스가 오래 기다려야 하는 상황을 Convoy effect(호위 효과)라고 한다. CPU 스케줄링에 있어서는 부정적인 효과이다.
- 긴 평균 응답 시간

<br>

### 1-2 )  SJF(Shortest Job First) 스케줄링 / SJN(Shortest Job Next) 스케줄링

📌 **설명**
FCFS를 살짝 보완한 알고리즘으로, 실행 시간이 짧은 프로세스가 우선순위를 갖는 알고리즘이다. preemptive와 non-preemptive 버전으로 구현가능하다. preemptive 버전은 SJF(Shortest Job First)이고, non-preemptive 버전은 SRTF(Shortest Remaining Time First)이다. 

📌 **장점**
- convoy effect를 해결하기 위한 방법
- 짧은 평균 대기시간
- 시스템 내 프로세스 수 최소화
	- 스케줄링 부하 감소, 메모리 절약으로 시스템 효율성 향상
- 많은 프로세스들에 빠른 응답 시간 제공

📌 **단점**
- **Starvation**이 발생
	- CPU burst time이 긴 프로세스는 영원히 후순위로 밀리며 CPU를 얻지 못하게 되는 문제가 발생할 수 있다.
- 정확한 프로세스의 CPU burst time을 알 수 없음
	- CPU burst time을 예측할 때는 과거의 CPU burst time을 기반으로 추정하는데, 최근의 CPU burst time을 더 많이 반영하고 과거의 값은 점점 적게 반영하는 방식인 **Exponential Averaging**을 사용한다. 따라서 짧은 CPU burst time을 예상했지만 CPU를 훨씬 길게 점유할 수도 있게 되는 문제가 발생할 수 있다.
- 짧은 작업이 먼저 실행되기에 공정하지 못함

<br>

### 1-3 ) Priority 스케줄링

📌 **설명**
이전의 SJF도 priority가 predicted next CPU burst time인 Priority 스케줄링이다. Priority 스케줄링도 non-preemptive와 preemptive 버전으로 구현 가능하다. 

📌 **특징**
SJF와 마찬가지로 Starvation이 발생할 수 있다. 이를 해결하는 방법이 **Aging 기법**이다. Aging 기법은 시간이 지날수록 우선순위를 높여주는 것이다.

<br>

### 1-4 ) HRRN(Highest Response Ratio Next) 스케줄링

📌 **설명**
Response Ratio를 계산하여 해당 값이 가장 높은 프로세스를 우선적으로 스케줄링하는 방법이다. 
**Response Ratio**는 **(대기시간 + CPU burst time)/CPU burst time** 으로 계산된다.
대기 시간이 길어질수록 Response Ratio가 증가하므로, 오랫동안 대기한 프로세스는 우선적으로 CPU를 할당받게 된다. 또한, CPU burst time이 짧을수록 Response Ratio가 높아지므로, 상대적으로 짧은 작업이 먼저 실행될 가능성이 높다.

📌 **특징**
SJF를 보완한 방법으로, SJF의 장점을 취하고 대기 시간을 고려하여 스케줄링해 Starvation 문제를 완화하지만 여전히 CPU burst time을 예측해야한다는 단점이 있다. 

<br><br>

### 2)  선점형 스케줄링 (preemptive scheduling)

스케줄러가 실행 중인 프로세스를 중단시키고 다른 프로세스를 실행할 수 있음을 의미한다. 

### 2-1 ) RR(Round Robin) 스케줄링

📌 **설명**
모든 프로세스를 순서대로 일정 시간동안 실행하며, 일정 시간을 초과하면 다른 프로세스를 실행하는 방법이다.
여기서 일정 시간은 '시간 단위'를 의미하며 **time quantum 또는 time slice**라고도 한다. 일반적으로 10~100 밀리초이다. 
이 방법은 n개의 프로세스가 Ready Queue에 있고 time quantum이 q time unit인 경우, 각 프로세스는 최대 q time unit으로 CPU 시간의 1/n을 얻게 된다. 즉, 모든 프로세스들이 (n-1)\*q time 이상 기다리지 않는다. 
대화형, 시분할 시스템에 적합하다. 

📌 **장점**
- Starvation 현상 발생하지 않음
- 응답 시간이 빠름
- 특정 프로세스의 자원 독점 방지

📌 **단점**
- context switching overhead 큼

📌 **Time quantum에 따른 Trade-Off**
- 큰 Time quantum
	- FCFS와 유사해짐
	- 응답성 감소
		- 한 프로세스가 지나치게 오랫동안 CPU를 점유하게 됨
		- 프로세스가 CPU 기다리는 시간 증가로 더 느린 응답과 실행
	- context switching overhead 감소
		- 상대적으로 긴 시간동안 CPU를 사용하므로 오버헤드 감소
- 작은 Time quantum
	- 응답성 증가
		- 프로세스가 더 빠르게 CPU를 얻어 더 빠른 응답과 실행
		- 빠른 응답성이 필요한 상황에 적합
	- context switching overhead 증가
		- 빈번한 프로세스 전환으로 오버헤드 증가

<br>

### 2-2 ) SRTF(Shortest Remaining Time First) 스케줄링

📌 **설명**
Ready Queue에서 남은 실행 시간이 가장 짧게 남은 프로세스를 우선 수행하는 알고리즘으로, SJF의 preemptive 버전이다. 
한 프로세스가 실행 중일 때 실행 시간이 더 짧은 프로세스가 Ready Queue에 들어오면 실행 시간이 더 짧은 프로세스가 CPU를 차지하게 된다. 

📌 **장점**
- 평균 대기시간를 최소화하여 시스템의 부하를 줄여주는 등 SJF의 장점 극대화

📌 **단점**
- Starvation이 발생
- 프로세스의 CPU burst time을 예측하기 힘듦
- 잔여 시간을 계속 추적해야해서 오버헤드 발생
- 선점형으로 Context Switching overhead 발생

<br>

### 2-3 ) 멀티 레벨 큐(multi level queue) 스케줄링

📌 **설명**
Ready Queue를 목적에 따라 여러 개로 분리해 사용하는 알고리즘이다. 

📌 **특징**
- 작업, 우선순위 별 별도의 ready queue가짐
	- 최초 배정된 큐 벗어나지 못함
	- 각각의 큐는 자신만의 스케줄링 기법 사용
- 큐 사이에는 우선순위 기반의 스케줄링 사용

📌 **장점**
- 우선시간이 높은 ready queue는 응답시간이 빠름

📌 **단점**
- 여러 개의 큐 관리 등 스케줄링 오버헤드 발생
- 우선순위가 낮은 큐는 Starvation이 발생 가능
	- 큐를 여러 개 두더라도 우선순위가 낮으면 여전히 CPU 할당 받지 못함

<br>

### 2-4) 멀티 레벨 피드백 큐(multi level feedback queue) 스케줄링

📌 **설명**
프로세스의 큐간 이동이 허용된 MLQ이다. MLQ의 최초 배정된 큐를 벗어나지 못해, 시스템 변화에 적용하기 힘든 단점을 극복하기 위해 나온 방법이다. 

📌 **특징**
- 피드백을 통해 우선순위 조정
	- 현재까지의 프로세서 사용 패턴 활용

📌 **장점**
- 프로세스에 대한 사전 정보(실행시간) 없이 SJF, SRTF, HRRN 기법 효과 볼 수 있음

📌 **단점**
- 설계 및 구현 복잡(여러개의 큐, 큐간의 이동)
- 스케줄링 오버헤드가 큼(변화하는 우선순위)
- Starvation이 발생 가능
	- 여전히 우선순위 낮은 프로세스는 CPU 할당 받지 못함

<br>
> ➕ **하이브리드 스케줄링**
  하나의 스케줄링 알고리즘에서 다양한 스케줄링 기준 또는 분야를 혼합하는 스케줄링 매커니즘을 의미함.

<br><br>

## 6. 동시성 vs 병렬성

### 동시성 (Concurrency)
- 싱글 코어에서 여러 스레드가 번갈아가며 실행
- 논리적인 개념
- 목표 : 유휴 시간을 최소화
	- 유휴 시간 : 컴퓨터가 작동 가능한데도 작업을 하지 않는 시간
- 발생할 수 있는 문제점
	- Race Condition : 여러 프로세스가 하나의 자원에 접근해 서로의 실행 결과에 영향을 주는 현상
	- Deadlock : 여러 프로세스가 서로 상대방의 작업이 끝나기를 무한히 기다리는 현상
	- Starvation : 특정 프로세스가 우선순위가 낮아 원하는 자원을 계속 할당받지 못하는 현상

### 병렬성 (Parallelism)
- 멀티 코어에서 여러 스레드를 동시에 실행
- 물리적인 개념
- 예시 : 분산 컴퓨팅 시스템
- 발생할 수 있는 문제점
	- 메모리 손상, 누수 : 여러 작업이 어떤 자원을 공유하고 있는지 고려해야하기 때문

<br>
