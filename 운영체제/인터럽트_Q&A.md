## 박상윤 
<details>
<summary>인터럽트 설명</summary>

- 예상치 못한, 외부에서 발생한 이벤트로, OS가 CPU의 정상적인 프로그램 실행을 방해했다는 의미
- CPU가 프로그램을 실행 중일 때 예외상황이 발생한 경우, CPU에게 알려 현재 실행중인 작업을 중단하고 발생된 상황을 처리하도록 하는 것

</details>

<details>
<summary>인터럽트 종류를 말하고, 어떤 상황에 발생되는 인터럽트인지 설명</summary>

- 외부 인터럽트 (`일반적인 인터럽트`)
    - CPU 외부로부터의 인터럽트 요구 신호에 의해 발생되는 인터럽트
    - 하드웨어 컨트롤러가 CPU의 서비스를 요청하기 위해 발생시키는 인터럽트
    - Machine check interrupt, I/O interrupt
- 내부 인터럽트 (`Trap: 트랩`)
    - CPU 내부에서 실행하면서 인터럽트에 걸리는 경우
    - 컴퓨터의 내부 시스템에서 생성되는 인터럽트
    - Program check interrupt
        - Division by zero
        - Overflow/Underflow
        - 기타 Exception
- 소프트웨어 인터럽트
    - `SVC interrupt`, 운영체제에게 제어권을 넘겨 해결하는 Supervisor Call
    - 시스템 콜과 같은 맥락으로, 운영체제에 서비스를 요청하기 위해 인터럽트를 걸고 커널모드로 전환하는 인터럽트

</details>

<details>
<summary>인터럽트가 필요 이유 설명</summary>

대부분의 컴퓨터는 한 개의 CPU만 사용하기 때문에, 어떤 일을 처리하는 도중 우선순위가 급한 일을 처리할 필요가 있을 때 대처할 수 있는 방안이 필요

멀티태스킹이 가능하려면 먼저 시작한 작업이라도 우선순위가 더 높은 작업을 먼저 처리하도록 지시할 수 있어야 하는데, 해당 기능이 인터럽트임

**인터럽트는 컴퓨터가 중요한 일이 생겼을 때, 지금 하던 작업을 잠깐 멈추고 그 중요한 일을 먼저 처리할 수 있게 도와주는 기능**

</details>

<details>
<summary>인터럽트 처리 과정 설명</summary>

1. 인터럽트 발생  
2. 프로세스 중단 (`커널 개입`)  
    - 프로세스의 정보를 PCB에 저장 (Context Saving)  
3. 인터럽트 처리 (`interrupt handling`)  
    - 인터럽트 발생장소, 원인 파악  
    - 인터럽트 **서비스 할 것인지 결정**  
4. 인터럽트 서비스 루틴 호출 (`interrupt service`)  
    - 인터럽트를 서비스하기로 결정했을 경우 진행  

</details>

<details>
<summary>인터럽트 발생시 처리해야 할 루틴의 주소를 보관하는 테이블 설명</summary>

인터럽트 벡터 테이블

</details>

<details>
<summary>하드웨어에는 어떤 레지스터있는지 설명</summary>

- `상태(Status)`
    - 하드웨어 장치의 현재 상태를 읽을 수 있는 레지스터
- `명령(Command)`
    - 하드웨어 장치가 특정 동작을 하도록 요청할때 사용
- `데이터(Data)`
    - 하드웨어 장치에 데이터를 주고받을 때 사용

</details>

---

## 신예지
<details>
<summary>하드웨어 인터페이스 레지터스의 종류와 각각의 역할에 대해 설명해주세요</summary>

- **`상태 레지스터 (Status Register)`:** 하드웨어 장치의 **현재 상태를 읽는 레지스터**  
- **`명령 레지스터 (Command Register)`:** 하드웨어 장치에 **명령을 내릴 때 사용**  
- **`데이터 레지스터 (Data Register)`:** 하드웨어 장치와 **데이터를 주고받는 레지스터**  

</details>

<details>
<summary>인터럽트 처리 과정을 설명해주세요</summary>

1. 인터럽트 발생  
2. 프로세스 중단 (`커널 개입`)  
    - 프로세스의 정보를 PCB에 저장 (Context Saving)  
3. 인터럽트 처리 (`interrupt handling`)  
    - 인터럽트 발생장소, 원인 파악  
    - 인터럽트 **서비스 할 것인지 결정**  
4. 인터럽트 서비스 루틴 호출 (`interrupt service`)  
    - 인터럽트를 서비스하기로 결정했을 경우 진행  

</details>

<details>
<summary>Interrupt와 Polling의 차이점을 동작 방식과 CPU 개입 방식에 따라 설명해주세요</summary>

- 인터럽트  
    - 하드웨어가 CPU에 직접 요청을 보내 작업을 처리  
    - 필요한 순간에만 CPU가 개입 (비동기적)  
- Polling  
    - CPU가 주기적으로 하드웨어 상태를 확인  
    - CPU가 계속해서 상태를 확인 (동기적)  

</details>

<details>
<summary>Polling의 동작 방식을 설명해주세요</summary>

1. 운영체제와 하드웨어간 상호작용  
    - 운영체제가 하드웨어 장치의 `상태 레지스터`를 읽음으로써 명령의 수신여부를 주기적으로 확인하는 것  
2. 운영체제가 `데이터 레지스터`에 데이터 전달  
3. 운영체제가 `명령 레지스터`에 명령을 기록  
4. 폴링 반복문 실행  
    - 운영체제는 하드웨어 장치가 특정 동작을 처리했는지 폴링 반복문을 돌며 기다림  
    - 성공/실패 코드를 받음  

</details>

<details>
<summary>하드웨어 인터럽트와 소프트웨어 인터럽트의 차이점을 설명해주세요</summary>

하드웨어 인터럽트는 외부 장치의 요청으로 발생하며, CPU가 실행 중이던 프로그램과 무관하게 개입됩니다.

소프트웨어 인터럽트는 프로그램이 직접 실행한 명령어로 인해 발생하며, 보통 OS의 기능을 사용하기 위한 시스템 호출과 관련됨.

</details>

<details>
<summary>외부 인터럽트의 예시를 들어주세요</summary>

- Machine Check Interrupt - CPU의 기능적 오류  
- I/O 인터럽트  
    - 입출력 장치가 데이터 전송을 요구하거나 전송이 끝나 다음 동작이 수행되어야 할 경우  
    - 입출력 데이터에 이상이 있는 경우  

</details>

---

## 김수훈
<details>
<summary>인터럽트의 종류와 각 인터럽트의 간단한 설명을 해주세요.</summary>

### 외부 인터럽트

- CPU 외부로부터의 인터럽트 요구 신호에 의해 발생되는 인터럽트
- 하드웨어 컨트롤러가 CPU의 서비스를 요청하기 위해 발생시키는 인터럽트

### 내부 인터럽트

- CPU 내부에서 실행하면서 인터럽트에 걸리는 경우
- 컴퓨터의 내부 시스템에서 생성되는 인터럽트로, CPU 내부에서 자신이 실행한 명령이나 CPU의 명령 실행에 관련된 모듈이 변화하는 경우 발생

### 소프트웨어 인터럽트

- SVC interrupt, 운영체제에게 제어권을 넘겨 해결하는 Supervisor Call
- 시스템 콜과 같은 맥락으로, 운영체제에 서비스를 요청하기 위해 인터럽트를 걸고 커널모드로 전환하는 인터럽트

</details>

<details>
<summary>통상적으로 HW인터럽트를 [ ], SW인터럽트는 [ ]이라는 용어를 사용한다.</summary>

인터럽트, 트랩(trap)

</details>

<details>
<summary>maskable interrupt와 non maskable interrupt를 인터럽트 플래그와 연관지어 설명해주세요.</summary>

인터럽트 플래그란 하드웨어 인터럽트를 받아드릴지 무시할지 결정하는 플래그인데, 이 때 모든 하드웨어 인터럽트를 인터럽트 플래그로 막을 수는 없습니다.

여기에서 막을 수 있는 인터럽트를 maskable interrupt, 막을 수 없는 인터럽트를 non maskable interrupt이라고 합니다.

</details>

<details>
<summary>인터럽트에 나오는 개념 중 ISR이 무엇인가요?</summary>

ISR은 인터럽트 서비스 루틴의 약자로 인터럽트가 발생했을 때 CPU가 실행하는 루틴을 말하며 해당 인터럽트를 처리하는 코드를 말합니다. 인터럽트 핸들러라고도 불립니다.

</details>

<details>
<summary>인터럽트의 폴링에서 특정 주기마다 확인한다는 특징으로 인해 발생하는 문제점이 무엇이 있나요?</summary>

- 시스템 리소스를 많이 소모  
- 정확한 타이밍에 시그널이 들어왔는지 확인 불가  
- 주기에 따른 오차 존재  
- CPU가 깨어있을때만 사용 가능  

</details>

---

## 변하영
<details>
<summary>인터럽트와 폴링의 차이를 설명해주세요</summary>

폴링은 CPU가 주기적으로 하드웨어 장치의 상태를 확인하는 방법이고, 인터럽트는 장치가 직접 CPU에게 알려 처리하는 방식입니다.

</details>

<details>
<summary>인터럽트 처리 순서를 설명해주세요</summary>

1. 인터럽트 발생  
2. 프로세스 중단 (Context 저장)  
3. 인터럽트 처리(발생원인/장소 파악, 서비스 할 것인지 결정)  
4. 인터럽트 서비스 루틴 호출 (서비스하기로 결정했을 경우)

</details>

<details>
<summary>프로그램에서 0으로 나누기를 시도했을 때 어떤 종류의 인터럽트가 발생하나요?</summary>

0으로 나누기는 정의되지 않은 연산이라 내부 인터럽트인 program check interrupt가 발생합니다.

</details>

<details>
<summary>maskable interrupt와 non maskable interrupt의 차이는 무엇인가요?</summary>

인터럽트 플래그를 0으로 설정했을 때 maskable interrupt는 막을 수 있고, non maskable interrupt는 막을 수 없습니다. non maskable interrupt는 무조건 처리해야 하며 치명적인 오류 발생(심각한 기억 장치 오류, 정전 사태) 시 사용됩니다.

</details>

<details>
<summary>polling의 동작 방식에 대해 설명해주세요</summary>

1. 운영체제와 하드웨어 간 상호작용합니다. 운영체제가 하드웨어 장치의 상태 레지스터를 읽음으로써 명령의 수신여부를 주기적으로 확인합니다.  
2. 운영체제가 데이터 레지스터에 데이터를 전달합니다.  
3. 운영체제가 명령 레지스터에 명령을 기록합니다.  
4. 폴링 반복문을 실행합니다. 운영체제는 하드웨어 장치가 특정 동작을 처리했는지 폴링 반복문을 돌며 기다립니다. 이 후 성공/실패 코드를 받습니다.

</details>

<details>
<summary>polling의 장단점에 대해 설명해주세요</summary>

**장점**  
- 구현이 쉽다.  
- 우선순위 조정이 용이하다.  
- 단순하고 예측이 가능하다.  
- 빠른 하드웨어 장치에는 유리하다. (오버헤드가 적을 수 있기에)  

**단점**  
- CPU를 계속 점유하여 자원 낭비가 심하다.  
- 정확한 타이밍 보장이 어렵다.  
- 주기 오차가 발생할 수 있다.  
- CPU가 항상 깨어있어야 한다.  
- CPU가 직접 일을 하기에 입출력 시간이 오래 걸린다.  
- 장치가 응답하지 않아도 루프를 돌며 리소스를 계속 사용하기에 시스템 리소스가 낭비된다.

</details>

---

## 이소원   
<details>
<summary>인터럽트가 뭔지 설명해주세요</summary>

CPU가 프로그램을 실행 중일 때 더 중요한 작업(입출력, 시스템 요청, 예외 등)이 발생하면, CPU에게 알려 현재 실행 중인 작업을 중단하고 발생된 상황에 대한 해당 요청을 우선 처리하는 매커니즘을 의미합니다.

</details>

<details>
<summary>인터럽트와 예외의 차이를 설명해주세요</summary>

인터럽트 : 외부 장치(키보드 입력, 타이머, 네트워크 등)에서 발생하며 CPU의 개입을 요구

예외 : 프로그램 실행 중 오류(0으로 나누기, 메모리 접근 오류 등)로 인해 발생하며, CPU가 즉시 처리해야 하는 것

</details>

<details>
<summary>폴링과 인터럽트를 비교해서 설명해주세요.</summary>

- 인터럽트 방식이 폴링보다 CPU 자원을 더 효율적으로 사용할 수 있습니다.  
- 빠른 하드웨어 장치(예: 키보드, 마우스)에서는 인터럽트 방식이 더 적절하지만, 아주 짧은 주기로 반응해야 하는 특정 환경(예: 실시간 임베디드 시스템)에서는 폴링이 더 나을 수 있습니다.  
- 인터럽트 방식에서는 Context Switching이 발생하지만, 폴링은 단순 반복이므로 Context Switching이 발생하지 않습니다.

</details>

<details>
<summary>인터럽트 처리 과정에 대해 설명해주세요</summary>

1. 주 프로그램 실행 도중 인터럽트 발생  
2. 프로세스 중단  
    1. 프로세스 정보를 PCB에 저장  
3. 인터럽트 처리  
    1. 인터럽트 발생 장소와 원인 파악  
    2. 인터럽트를 서비스할지 결정  
4. (인터럽트를 서비스 하기로 결정했다면) 인터럽트 서비스 루틴 호출

</details>

<details>
<summary>실시간 대응에 필요한 방식은 무엇인가요?</summary>

**인터럽트**

- 이유  
    인터럽트 방식은 하드웨어의 지원을 받아야 하는 제약이 있지만, 폴링에 비해 신속하게 대응하는 것이 가능합니다.  
    폴링은 일정 시간마다 주기적으로 체크하는 것이므로 타이밍이 맞지 않으면 지연이 생길 수 있습니다.

</details>