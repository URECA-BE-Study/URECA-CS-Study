# 프로세스란
프로세스는 실행 중인 프로그램을 의미한다.

운영체제는 프로그램을 실행하면 독립적인 실행 공간을 할당하고 이 실행 단위를 프로세스라고 부른다.

## 프로세스의 특징
- 독립적인 메모리 공간(Code, Data, Heap, Stack 영역)을 가짐
→ 하나의 프로세스가 다른 프로세스의 메모리에 직접 접근할 수 없음.
- 운영체제(OS)에 의해 스케줄링됨
→ 운영체제가 여러 프로세스를 효율적으로 실행하도록 관리함.
- 멀티프로세싱(Multi-processing)이 가능
→ 여러 개의 프로세스를 동시에 실행할 수 있음(병렬 실행).

## 프로세스의 메모리 구조

프로세스는 다음과 같은 메모리 영역을 가진다.

1.	Code(텍스트) 영역: 실행할 프로그램의 코드(명령어) 저장
2.	Data 영역: 전역 변수, 정적 변수 저장
3.	Heap 영역: 동적으로 할당된 메모리 공간 (ex: malloc(), new)
4.	Stack 영역: 함수 호출 시 지역 변수와 리턴 주소 저장

**각 프로세스는 독립적인 메모리 공간을 가지므로, 다른 프로세스의 메모리에 직접 접근할 수 없다.**

만약 프로세스 간 데이터를 공유하려면 <b>IPC(Inter-Process Communication, 프로세스 간 통신)</b>을 사용해야 한다.

## 프로세스의 상태

### New
프로세스가 새로 생성된 상태

메모리 자원 할당을 기다리고 있음
### Ready
1. New 상태에서 메모리 할당을 받거나
2. Running 상태에서 time out이 걸리거나
3. Blocked 상태에서 작업이 끝나면 Ready 상태가 됨

### Running
Ready 상태에서 CPU를 할당 받으면 Running 상태가 됨

### Blocked
Running 상태에서 스스로 CPU를 포기하면 Blocked 상태가 됨

> Ready 큐와 Blocked 큐는 분리되어 있다

### Exit
Running 상태에서 프로세스가 할 일이 끝난 상태

프로세스가 사용하던 자원을 반납하고, 정상 종료 됐는지 확인해야 함

### 프로세스의 다섯 가지 상태 그림
![프로세스의 다섯 가지 상태](https://github.com/user-attachments/assets/5677ac24-89d2-47b8-b6b7-233d223f27ac)

### 프로세스의 일곱 가지 상태 그림(Suspend 상태 추가)
> **suspend란?** 프로세스가 하드디스크로 쫓겨난 상태

![프로세스 상태](https://github.com/user-attachments/assets/47c202c2-d7b5-44ca-9cc1-595abcee9678)

## 프로세스의 사용 예시
- 웹 브라우저(Chrome, Firefox)
→ 각 탭이 별도의 프로세스로 실행됨 (한 탭이 멈춰도 다른 탭에는 영향 없음)
- 운영체제에서 실행되는 프로그램 (메신저, 미디어 플레이어 등)
→ 각 프로그램은 독립적인 프로세스로 실행됨


# 스레드
스레드는 프로세스 내에서 실행되는 작업 단위이다.

즉, 하나의 프로세스가 여러 개의 스레드를 가질 수 있고 각 스레드는 같은 메모리 공간을 공유하면서 실행된다.

## 스레드의 특징
- 같은 프로세스 내에서 Stack을 제외한 모든 메모리(Code, Data, Heap)를 공유
- 병렬(동시) 실행 가능
- 스레드 간 컨텍스트 스위칭 비용이 적음
- 다른 프로세스의 스레드와 직접 메모리를 공유할 수 없음

## 스레드의 메모리 구조
프로세스와 다르게, 스레드는 프로세스의 메모리 공간을 공유하면서 실행된다.

각 스레드는 독립적인 Stack 영역을 가지지만, Code, Data, Heap 영역은 공유한다.

| 메모리 영역 | 프로세스 | 스레드 |
|---|---|---|
| Code (코드) | 공유하지 않음 (각 프로세스마다 독립적) | 공유 |
| Data (전역 변수, 정적 변수) | 공유하지 않음	| 공유 |
| Heap (동적 할당 메모리)	| 공유하지 않음 | 공유 |
| Stack (지역 변수, 함수 호출 정보) |	독립적 | 독립적 |

## 스레드의 사용 예시
- 웹 서버 (Apache, Nginx)
→ 하나의 프로세스가 여러 개의 스레드를 사용하여 클라이언트 요청을 동시에 처리
- 게임 프로그램
→ 한 스레드는 그래픽을 렌더링, 다른 스레드는 네트워크 통신을 담당

# 멀티프로세스(Multi-Process) vs 멀티스레드(Multi-Thread)

| 비교 항목	| 멀티프로세스 | 멀티스레드 |
|---|---|---|
| 개념	| 여러 개의 프로세스를 생성하여 실행 | 하나의 프로세스 내에서 여러 개의 스레드를 실행 |
| 메모리 사용량 | 크다 (각 프로세스마다 메모리 할당 필요) | 적다 (스레드끼리 메모리 공유) |
| 안정성 |	한 프로세스가 오류 나도 다른 프로세스에는 영향 없음	| 한 스레드가 오류 나면 전체 프로세스가 영향을 받을 수 있음 |
| 문맥 전환 비용 |	높음	| 낮음 |
| 데이터 공유 | 불가능 (IPC 필요) |	가능 (Heap, Data 영역 공유) |

## 멀티프로세스가 유리한 경우
- 안정성이 중요한 경우 (웹 브라우저의 각 탭)
- 프로세스 간 공유할 데이터가 많지 않은 경우

## 멀티스레드가 유리한 경우
- 빠른 실행 속도가 중요한 경우 (게임, 웹 서버)
- 공유 데이터가 많아야 하는 경우 (파일 다운로드, 채팅 프로그램)

# 추가 조사
## 데이터 영역
1.	.data 영역 → 초기화된 전역 변수 & 정적 변수
2.	.bss 영역 → 초기화되지 않은 전역 변수 & 정적 변수

### BSS 영역
**BSS(Block Started by Symbol)란?**

초기화되지 않은 전역 변수와 정적(static) 변수가 저장되는 데이터 영역
- 실제로 실행 파일의 크기에는 영향을 주지 않지만, 프로그램 실행 시 메모리에 할당되면서 0으로 초기화됨
- 프로그램이 종료될 때까지 메모리에 유지됨
- 실행 파일 크기를 줄이는 데 기여함

## PID 0
리눅스 커널에서 존재하는 스왑퍼(Swapper) 또는 아이들(Idle) 프로세스
➡ 유저 프로세스가 아니라 CPU가 놀지 않도록 관리하는 특별한 커널 태스크

### PID의 역할
1. CPU가 쉴 때, Idle 상태를 유지함

- 실행할 프로세스가 없으면 hlt(halt) 명령어를 실행해 전력 소모를 줄임

2. 다음에 실행할 프로세스를 스케줄링함

- CPU가 실행할 프로세스를 결정하는 데 도움을 줌

3. 부팅 시 첫 번째 유저 프로세스(PID 1)를 생성함

- 보통 init 또는 systemd가 PID 1이 돼서 나머지 프로세스를 생성함

## TLB에서 말하는 가상 주소와 물리 주소

### 가상 주소(Virtual Address)란?
- CPU가 메모리에 접근할 때 사용하는 논리적 주소
- 각 프로세스마다 독립적인 가상 주소 공간을 가짐
- 실제 RAM의 주소(물리 주소)와는 다름!

### 물리 주소(Physical Address)란?
- 실제 RAM에서 해당 데이터가 저장된 주소
- MMU(Memory Management Unit)가 가상 주소 → 물리 주소로 변환

### TLB(변환 조회 버퍼, Translation Lookaside Buffer)란?
- 가상 주소 → 물리 주소 변환을 빠르게 하기 위한 캐시
- 변환할 때 페이지 테이블을 직접 찾으면 느리므로, 자주 사용되는 변환 정보를 캐싱함

### TLB 동작 과정
1. CPU가 가상 주소를 사용해 데이터 요청
2. TLB에서 해당 가상 주소의 매핑 정보(물리 주소)를 검색
- TLB Hit: 변환 정보가 있으면 바로 물리 주소 반환
- TLB Miss: 없으면 페이지 테이블을 검색하고, 변환 결과를 TLB에 저장

**[가상 주소] → (TLB) → [물리 주소] → (메모리 접근)**
