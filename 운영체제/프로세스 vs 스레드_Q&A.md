## 신예지
<details>
<summary><b>프로그램과 프로세스의 차이를 설명해주세요</b></summary>
<div markdown="1">
  하드디스크와 같은 저장 장치에 존재하는 실행 코드의 집합을 프로그램이라 하고, 프로그램이 메모리에 적재되어 실행되는 작업 단위를 프로세스라고 합니다. 프로그램과 프로세스는 메모리의 적재 유무의 차이라고 볼 수 있습니다.
</div>
</details>

<details>
<summary><b>스레드 단위로 관리되는 자원에는 대표적으로 스택이 있습니다. 그렇다면 스택은 왜 스레드 단위로 관리되는지 설명해주세요(PCB 맛보기..?)</b></summary>
<div markdown="1">
  스택은 함수 호출시 전달되는 인자, 복귀 주소값 및 함수 내에서 선언하는 변수(지역변수) 등을 저장하기 위해 사용되는 메모리 공간입니다. 스레드는 독립적으로 실행되는 작업 단위이므로 스레드마다 스택을 갖고 있어야합니다.  
</div>
</details>

<details>
<summary><b>스레드의 장점을 설명해주세요</b></summary>
<div markdown="1">
  
- 시간이 적게 소요됨 - 스레드 생성 시간, 스레드 종료 시간, 스레드 교체(switching)
- 프로세스와 자원을 공유해 커널의 간섭을 최소화 할 수 있음
- 일부 스레드의 처리가 지연되어도 다른 스레드는 작업 계속 처리 가능
</div>
</details>
    
<details>
<summary><b>멀티프로세스와 멀티스레드의 장단점을 설명하고, 각 방식이 실제 상황에서 어떻게 사용하는지 설명해주세요</b></summary>
<div markdown="1">
  
  멀티프로세스는 다른 프로세스가 메모리에 접근할 수 없기 때문에 안정성이 높다는 장점이 있지만, 메모리 사용량이 크고 context switching으로 인해 오버헤드(어떤 처리를 하기 위해 들어가는 간접적인 비용이나 시간, 메모리 등)가 발생해 성능이 저하될 수 있다는 단점이 있습니다. +) 기본적으로는 프로세스 간 자원 공유를 할 수 없어서 프로세스 간에 통신을 하기 위해서는 IPC라는 복잡한 방법을 사용해야 한다.
    
  멀티스레드는 프로세스 내에서 스레드끼리 자원을 공유하기 때문에 메모리 사용량이 적고, context switching을 할 때 시간이 적게 소요된다는 장점이 있지만, 자원을 공유하기 때문에 안정성이 낮고 하나의 스레드에 문제가 생기면 전체 프로세스가 영향을 받는다는 단점이 있습니다.
    
  멀티프로세스는 안정성이 중요하거나 프로세스 간 공유할 데이터가 적을 경우에 사용합니다. 예를 들어 웹 브라우저의 각 탭이 있습니다.
  
  멀티스레드는 빠른 실행 속도가 중요하거나 공유할 데이터가 많을 경우에 사용합니다. 예를 들어 게임, 웹 서버, 채팅 프로그램이 있습니다.

   ### **꼬리질문**
   <b>그렇다면 멀티스레드의 단점을 보완하기 위해 어떤 방법이 사용될까요?</b>
   
   멀티스레드의 단점은 결국 동기화 문제이므로 Mutex(뮤텍스), Semaphore(세마포어) 같은 동기화 기법이 사용됩니다.
</div>
</details>

<details>
<summary><b>프로세스의 다섯 가지 상태 중 Ready 상태와 Blocked 상태의 차이점을 설명해주세요</b></summary>
<div markdown="1">
  Ready 상태는 Running 상태에서 timeout과 같이 외부에 의해 자원(메모리)을 빼았겼을 때 가는 상태로 메모리를 할당하면 즉시 실행할 수 있는 상태입니다.
  
  Blocked 상태는 Running 상태에서 I/O 인터럽트와 같이 스스로 자원을 포기했을 때 가는 상태로 메모리를 할당해도 실행할 수 없는 상태입니다.
</div>
</details>
        
<details>
<summary><b>New 상태에서 Ready/Suspend 상태로 가는 것과 New 상태에서 Ready 상태로 가는 것의 차이점을 설명해주세요</b></summary>
<div markdown="1">
  New → Ready/Suspend는 프로세스가 생성되었지만 메모리가 부족하거나 정책적으로 우선순위가 낮아 바로 실행 대기 상태로 가지 못하는 경우이고, New → Ready는 프로세스가 생성되었고, 실행을 위해 메모리를 할당받을 수 있는 경우입니다.
</div>
</details>
    
<details>
<summary><b>Running 상태에서 Ready 상태로 가는 것과 Running 상태에서 Blocked 상태로 가는 것의 차이점을 설명해주세요</b></summary>
<div markdown="1">
  Running → Ready는 timeout이 됐을 경우, Running → Blocked는 스스로 CPU를 포기할 경우(ex. I/O 인터럽트)입니다.
</div>
</details>   


<details>
<summary><b>프로세스와 스레드의 생성 방법 중 fork()와 clone()을 메모리 관점에서 비교해서 설명해주세요</b></summary>
<div markdown="1">
  fork()는 부모 프로세스의 메모리 공간(코드, 데이터, 힙, 스택 등)이 그대로 복제 하지만, clone()은 stack만 분리하고 나머지 자원은 공유합니다.
</div>
</details>

<details>
<summary><b>리눅스에서 데몬 프로세스를 만드는 핵심적인 기술?을 설명해주세요</b></summary>
<div markdown="1">
  부모 프로세스로부터 fork()하여 자식 프로세스를 만들고, 부모 프로세스를 종료하여 고아 프로세스로 만듭니다. 이후 init 프로세스(PID1)이 고아 프로세스를 입양하여 관리합니다. → **init 프로세스는 모든 고아 프로세스의 부모**
</div>
</details>

<details>
<summary><b>Copy-On-Write 메커니즘은 언제 사용되나요?</b></summary>
<div markdown="1">
  fork() 과정에서 자식 프로세스가 부모 프로젝트의 메모리 공간을 복제하는데, fork() 동안에는 같은 메모리를 공유하다가 메모리의 데이터를 수정하면 그 때 복사하는 방식을 말한다.
  
  https://code-lab1.com/copy-on-write/
</div>
</details>

<details>
<summary><b>O/X 문제</b></summary>
<div markdown="1">
  
  - 프로세스의 다섯 가지 상태 중 Ready 상태와 Blocked 상태의 대기 큐는 분리돼있다.
    - O    
  - Ready/Suspend 상태에서 Blocked/Suspend 상태로 이동할 수 있다.
    - X, Blocked/Suspend 상태에서 Ready/Suspend 상태로만 이동 가능하다.
- fork() 없이 exec()만 실행할 수 있다.
    - O, exec()만 실행할 수는 있지만 현재 실행중인 프로세스는 사라짐
</div>
</details>

---

## 이소원

<details>
<summary><b>왜 하나의 스레드가 오류를 발생시키면 전체 프로세스에 영향을 끼칠 수 있나요?</b></summary>
<div markdown="1">
  스레드는 메모리를 공유하기 때문입니다.
</div>
</details>

<details>
<summary><b>프로세스와 스레드의 차이를 설명하세요.</b></summary>
<div markdown="1">
  프로세스는 메모리에 로드되어 현재 실행되고 있는 프로그램을 의미하고 독립적인 메모리를 가집니다.
  스레드는 한 개의 프로세스에 있는 동작 단위 입니다. 하나의 프로세스에서 스택을 제외한 메모리를 공유하며, 여러 개의 스레드가 동작하여 병렬처리가 가능합니다.
</div>
</details>

<details>
<summary><b>메모리 공유 측면에서 프로세스와 스레드의 차이를 설명해주세요</b></summary>
<div markdown="1">

  - 프로세스는 독립적이기 때문에 하나의 프로세스가 오류가 발생해도, 다른프로세스에 영향을 주지 않습니다.

    ex 1)
    인터넷창과 게임창을 켜놓고 플레이 할 때 게임이 에러가 나더라도 인터넷창까지 영향을 주지않습니다.

    ex 2)
    크롬으로도 예시를 들 수 있는데 크롬 브라우저는 각 탭을 별도의 프로세스로 실행하여 하나의 탭이 충돌해도 다른 탭에는 영향을 주지 않는다.
  - 스레드는 하나의 프로세스 내에서 실행되며 코드, 데이터, 힙 영역을 공유하지만 스택은 독립적으로 가집니다.
    이 때문에 경쟁 상태(Race Condition), 데드락(Deadlock), 스택 오버플로(Stack Overflow), 메모리 누수(Memory Leak)은 문제가 발생할 수 있습니다.

    따라서 동기화 문제를 해결하여 데이터 무결성 문제가 발생하지 않도록 해야합니다.
  
    - 경쟁 상태 : 여러 스레드가 동시에 공유 변수에 접근하면서 연산 결과가 꼬이는 상황
    - 데드락 : 두 개 이상의 스레드가 서로 가진 락을 기다리는 시간이 길어지는 상황
    - 메모리 누수 : 동적으로 할당된 메모리를 해제하지 않아 사용하지 않는 메모리가 반환되지 않는 현상
</div>
</details>

<details>
<summary><b>모든 멀티 스레드 방식은 하나의 스레드가 중단되면 전체 스레드가 중단되는건가요?</b></summary>
<div markdown="1">
  
  아닙니다. 이는 멀티 스레드 방식은 유저레벨 스레드의 방식에 해당됩니다. 유저레벨 스레드는 커널이 사용자 프로세스의 스레드를 인지하지 못하고 프로세스만 인지하기 때문에 하나의 스레드가 중단되면 전체 프로세스의 스레드가 중단된다는 단점이 존재합니다.
    
  +) 커널레벨 스레드는 다릅니다. 커널레벨 스레드는 커널에서 스레드 정보와 프로세스 정보를 모두 관리하기 때문에 하나의 스레드가 중단되어도 다른 스레드까지 중단되지 않고 정상적으로 작동합니다
    
</div>
</details>

<details>
<summary><b>멀티 스레드의 동시성과 병렬성을 설명해주세요.</b></summary>
<div markdown="1">
  동시성은 작업을 위해 싱글 코어에서 여러 개의 스레드가 번갈아 실행되는 것을 말합니다. 짧은 실행 시간으로 번갈아 가면서 실행하여 동시에 실행하는 것처럼 보이는 것을 말합니다.
    
  병렬형은 멀티 작업을 위해 멀티 코어에서 한 개 이상의 스레드를 포함하는 각 코어에서 동시에 실행하는 것을 말합니다.
</div>
</details>

<details>
<summary><b>멀티 스레드 환경에서 주의할 점이 있을까요?</b></summary>
<div markdown="1">
   다수의 스레드가 공유 데이터에 동시에 접근하는 경우 상호배제 또는 동기화 기법을 통해 동시성 문제 또는 교착 상태가 발생하지 않도록 주의애햐 합니다.
</div>
</details>

<details>
<summary><b>멀티 스레드 환경에서 주의할 점이 있을까요?</b></summary>
<div markdown="1">
   다수의 스레드가 공유 데이터에 동시에 접근하는 경우 상호배제 또는 동기화 기법을 통해 동시성 문제 또는 교착 상태가 발생하지 않도록 주의애햐 합니다.
</div>
</details>

<details>
<summary><b>프로세스와 스레드의 적합한 활용 예시는 뭘까요?</b></summary>
<div markdown="1">
   
  - 프로세스는 독립적 메모리 사용과 각 프로세스가 서로 접근하지 못하여 보안정을 보장합니다.
    
    - **웹 서버**: 각 클라이언트 요청을 별도의 프로세스로 처리하여 독립성을 보장하고, 하나의 요청 처리 중 오류가 발생해도 다른 요청에는 영향을 미치지 않도록 한다.
    - **운영 체제의 핵심 서비스**: 중요한 시스템 서비스나 데몬 프로세스는 독립적인 프로세스로 실행되어 안정성을 보장한다.
    - **데이터베이스 관리 시스템**: 데이터베이스 서버는 각 클라이언트 연결을 독립된 프로세스로 처리하여 안정성과 성능을 보장한다.ex) 오라클 DMBS는 각 사용자 세션을 별도의 프로세스로 처리하여 동시에 여러사용자가 DB에 접근할 수 있는 것을 돕는다고 한다.
    
  - 스레드는 문맥 교환이 상대적으로 가볍고 자원을 공유하기 때문에 빠른 통신과 데이터 교환이 가능합니다.
    
    - **GUI 애플리케이션**: 사용자 인터페이스와 백그라운드 작업을 별도의 스레드로 분리하여 사용자 응답성을 높인다.
    - **실시간 게임**: 게임 로직, 물리 엔진, 렌더링 등을 각각의 스레드로 나누어 실시간 성능을 보장한다.
    - **웹 서버의 요청 처리**: 프로세스 대신 스레드를 사용하여 각 요청을 처리하여 메모리 사용을 최적화하고 빠른 전환을 보장한다.
    
    각 장단점 → 사용 예시
    
    https://michael-cho.tistory.com/25
</div>
</details>

---

## 변하영

<details>
<summary><b>프로세스의 주소 공간에 대해 설명해보세요</b></summary>
<div markdown="1">
  프로세스의 주소 공간은 운영체제가 할당하는 논리적 메모리 공간으로, 코드, 데이터, 스택, 힙으로 나눌 수 있습니다. 스택은 지역 변수와 함수의 매개 변수가 저장되는 영역이고, 힙은 동적 메모리 할당이 일어나는 영역입니다. 데이터 영역에는 전역 변수, 정적 변수, 배열, 구조체 등이 저장됩니다. 데이터 영역은 다시 초기화 하기 전 전역 변수를 저장하는 BSS 영역과 초기화 한 전역 변수를 저장하는 데이터 영역으로 나뉩니다. 코드 영역은 기계어가 저장되어 있습니다. 
</div>
</details>

<details>
<summary><b>프로세스와 스레드의 차이점을 설명해보세요</b></summary>
<div markdown="1">
  프로세스는 실행 중인 하나의 프로그램을 의미하며 실행의 단위라고 할 수 있습니다. 반면에 스레드는 프로세스 내에서 실행되는 흐름의 단위를 의미합니다. 그래서 프로세스는 독립적인 메모리 영역을 갖지만, 스레드는 스택 영역만 독립적이고, 그 외 영역은 다른 스레드와 공유합니다. 
</div>
</details>

<details>
<summary><b>스택 오버플로와 힙 오버플로에 관해 설명해보세요</b></summary>
<div markdown="1">
  스택 오버플로우는 재귀함수가 너무 깊거나 스택 메모리를 초과할 때 발생합니다. 반면에 힙 오버플로우는 동적 메모리 할당이 너무 많아 힙 공간이 부족할 때 발생합니다. 스택 오버플로우는 프로그램이 즉시 종료되지만, 힙 오버플로우는 메모리 누수로 이어질 수 있습니다. 
</div>
</details>

<details>
<summary><b>PCB가 무엇인지 설명해보세요</b></summary>
<div markdown="1">
  PCB는 Process Control Block의 준말로, 프로세스에 대한 정보를 저장하는 구조체입니다. OS가 관리상 사용하는 정보인 스케줄링 정보,  포인터, 프로세스 상태, PID 등과 문맥 표시를 위한 PC값, 레지스터 값과 메모리 관련 정보와 파일 관련 정보가 저장되어 있습니다. 
</div>
</details>

<details>
<summary><b>멀티스레드와 멀티스레드의 차이점을 설명해보세요</b></summary>
<div markdown="1">
  멀티 프로세스는 응용 프로그램 하나를 프로세스 여러 개로 구성하는 것입니다. 반면에 멀티 스레드는 한 프로세스 안에서 여러 스레드로 작업을 처리하는 것입니다. 프로세스는 독립적인 메모리 영역을 갖기 때문에 자원 공유와 통신을 하려면 IPC를 활용해야 합니다. 스레드는 자원 공간을 공유하므로 스레드 간 통신과 자원 공유가 간단하고 프로세스 대비 context switching 비용이 적게 들지만 동기화가 필요합니다. 
</div>
</details>

<details>
<summary><b>context switching이 무엇인지 설명해보세요</b></summary>
<div markdown="1">
  CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정을 말합니다. CPU가 다른 프로세스로 넘어갈때 CPU를 내어주는 프로세스 상태를 해당 프로세스의 PCB에 저장합니다. 그리고 새롭게 얻는 프로세스의 상태를 해당 프로세스의 PCB에서 불러옵니다. 
</div>
</details>

<details>
<summary><b>멀티 프로세스에서 context switching과 멀티 스레드에서 context switching의 차이점을 설명해보세요</b></summary>
<div markdown="1">
  멀티프로세스는 프로세스 별로 고유한 메모리 영역을 갖는 반면에 멀티스레드는 스택 영역을 제외한 메모리 영역을 공유합니다. 따라서 멀티 스레드의 경우 레지스터에 로드해야 하는 데이터 양이 적어서 context switching 오버헤드가 적게 발생합니다. 
</div>
</details>

<details>
<summary><b>자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?</b></summary>
<div markdown="1">
  
  자식 프로세스가 상태를 알리지 않고 죽은 경우 좀비 프로세스가 발생합니다. 이를 해결하기 위해서는 부모가 wait() 시스템콜을 호출하여 자식의 종류 상태를 회수해야 합니다. 
    
  부모 프로세스가 먼저 죽게 되면 자식 프로세스는 고아 프로세스가 됩니다. 고아 프로세스는 init(1) 프로세스가 자동으로 입양하여 관리합니다.
  
</div>
</details>

---

## 박상윤

<details>
<summary><b>프로세스와 스레드이 차이점이 뭘까요?</b></summary>
<div markdown="1">
  
  프로세스는 독립적, 스레드는 종속적
    
  - 프로세스는 독립적인 실행 단위로, OS에서 별도의 자원을 할당받아 실행됩니다.
  - 반면, 스레드는 하나의 프로세스 내에서 실행되는 흐름 단위로, 같은 프로세스 내 다른 스레드와 자원을 공유하며 실행됩니다.
    
  **컨텍스트 스위칭 비용 차이**
    
  - 프로세스 간 컨텍스트 스위칭은 PCB(Process Control Block)를 저장하고 복원해야 하므로 오버헤드가 큽니다.
  - 반면, 스레드 간 컨텍스트 스위칭은 같은 PCB를 공유하므로 비용이 상대적으로 작습니다.
    
  **메모리 공유 방식 차이**
    
  - 프로세스는 독립적인 주소 공간(코드, 데이터, 힙, 스택 포함)을 가집니다.
  - 스레드는 코드, 데이터, 힙을 공유하지만, 각 스레드마다 독립적인 스택을 가집니다.
</div>
</details>

<details>
<summary><b>멀티 프로세스와 멀티 스레드에서 "컨텍스트 스위칭" 비용 차이가 발생하는 이유는 무엇인가요?</b></summary>
<div markdown="1">
  
  - 프로세스 간 컨텍스트 스위칭 비용이 높은 이유
      - 독립적인 메모리 주소 공간을 사용하므로 페이지 테이블을 변경해야 함.
      - TLB Flush가 발생할 가능성이 있어 메모리 접근 성능이 저하될 수 있음.
      - PCB(Process Control Block) 를 저장 및 복원하는 과정이 필요하여 오버헤드가 큼.
  
  - 스레드 간 컨텍스트 스위칭 비용이 낮은 이유
      - 스레드는 같은 PCB를 공유하므로 주소 공간 변경이 필요 없음.
      - TLB Flush가 발생하지 않음 → 메모리 접근 성능이 유지됨.
  
  Process Context Switching 과정 = **커널 모드 전환** + **CPU register 상태 교체** + 가상 메모리 주소 처리(**MMU 수정** + **TLB 캐시 비우기**)
    
  Thread Context Switching 과정 = **커널 모드 전환** + **CPU register 상태 교체**
    
  - 맞추지 말라고 낸 문제 ) TLB가 무엇이고 , TLB flush는 왜 해주나요?
  
  TLB(Translation Lookaside Buffer는 CPU가 **가상 주소(Virtual Address)를 물리 주소(Physical Address)로 변환할 때 사용하는 캐시**입니다.
        
  운영체제는 **가상 메모리**를 사용하기 때문에, 프로그램이 메모리에 접근할 때 페이지 테이블(Page Table)을 통해 물리 메모리 주소를 찾아야 합니다.
        
  TLB flush는 **CPU가 프로세스를 사용하면서 TLB에 저장한 매핑 정보를 모두 지우는 과정입니다.**
        
  프로세스 컨텍스트 스위칭이 발생하면, **CPU가 실행하는 프로세스가 변경되므로 메모리 주소 공간도 변경**됩니다.
  
</div>
</details>

<details>
<summary><b>멀티 스레드는 코드, 데이터, 힙 영역을 공유하는것처럼 멀티 프로세스도 공유할 수 있습니다. 공유하는 방법이 뭐가 있을까요?</b></summary>
<div markdown="1">

  1. 공유 메모리를 사용해서 공유한다.
     - 가장 빠른 IPC 방식 중 하나로, **둘 이상의 프로세스가 동일한 물리 메모리 영역을 공유하여 데이터를 주고받습니다.**
     - 단, **동기화 문제(예: 데이터 경합)가 발생할 수 있으므로 세마포어나 뮤텍스를 사용하여 보호해야 합니다.**
  3. 소켓을 사용해서 공유한다.
  4. 세마포어를 사용해서 공유한다.
  5. 파이프를 사용해서 공유한다.
  6. 메시지 큐를 사용해서 공유한다.
</div>
</details>

<details>
<summary><b>IPC를 통해 여러 프로세스가 공유 자원에 접근할때에 발생하는 데이터의 일관성이 깨지는 문제를 어떻게 해결할 수 있을까요? 해결 방법과 각 방법의 원리를 설명해주세요.</b></summary>
<div markdown="1">
  
  1. 뮤텍스 : 락을 가진 프로세스만 공유 자원에 접근할 수 있도록 하는 락킹 매커니즘을 사용합니다.
  2. 세마포어 : 공유 자원에 접근할 수 있는 프로세스의 수를 정해 접근을 제어하는 방법입니다. 공유 자원에 접근한 프로세스가 접근을 해제하는 경우 다른 프로세스가 접근할 수 있도록 신호를 보낸다는 의미에서 이를 시그널링 매커니즘이라고 합니다. 
</div>
</details>
    
<details>
<summary><b>교착 상태의 4가지 조건과 각 조건이 의미하는 바를 설명하세요.</b></summary>
<div markdown="1">

  상호 배제 : 하나의 자원은 한 번에 하나의 프로세스만 사용 가능
    
  점유와 대기 : 자원을 점유한 프로세스가 추가 자원을 기다림
    
  비선점 : 할당된 자원을 강제로 빼앗을 수 없음
    
  환형 대기 :  프로세스가 자신의 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구함
    
</div>
</details>

<details>
<summary><b>B프로세스는 A프로세스의 자식 프로세스입니다. A프로세스가 실수로 종료가 된 후에 B프로세스를 회수하지 않았습니다. 이때 OS는 어떠한 조치를 취해줄까요? 만약 OS가 이러한 조치 취하지 않는다면 어떠한 문제가 발생할까요?</b></summary>
<div markdown="1">

   B프로세스가 좀비 프로세스가 될 수 있기 때문에 자식 프로세스의 부모 PID를 init프로세스의 PID인 1로 변경해 줍니다. 이후 고아 프로세스가 작업이 종료되는 경우 init 프로세스가 고아 프로세스의 자원을 회수함으로 **좀비 프로세스가 되는 것을 방지**합니다.
   
   - 왜 init 프로세스를 사용할까요?
        
     프로세스는 운영체제에서 가장 먼저 실행되는 프로세스(PID 1)**이기 때문에 모든 프로세스의 최상위 부모 역할**을 한다.
        
     **운영체제가 안정적으로 프로세스를 관리할 수 있도록**, 부모가 없는 고아 프로세스를 프로세스가 대신 관리하여 **좀비 프로세스를 방지**한다.

     프로세스는 **강제 종료되지 않는 핵심 시스템 프로세스** 이므로, 모든 고아 프로세스를 안전하게 회수할 수 있다.
</div>
</details>

---

## 김수훈

<details>
<summary><b>같은 프로세스 내에 있는 스레드는 코드, 데이터, 힙은 공유하지만 스택은 공유하지 않습니다. 이 이유가 무엇일까요?</b></summary>
<div markdown="1">
  
  스택에는 함수 호출 정보, 지역 변수, 매개변수가 저장되기 때문입니다.
    
  스택을 공유하면 스레드 간 함수 실행 흐름이 꼬이고, 지역 변수가 덮어쓰기될 위험이 있기 때문에 스택을 공유하지 않습니다.
</div>
</details>

<details>
<summary><b>하나의 프로세스 내에 멀티 스레딩이 이루어지는 상황에 대한 예시를 들어보세요.(웹 제외)</b></summary>
<div markdown="1">

  게임을 실행할 때를 예시로 들 수 있습니다.
    
  하나의 게임을 실행할 때 하나의 프로세스가 실행되지만 그 속에서
    
  화면을 실시간으로 렌더링하는 스레드, 서버와 데이터를 주고 받으며 플레이어의 값을 처리해주는 스레드, 키보드, 마우스 입력을 감지하고 게임 캐릭터를 움직이는 입력 처리 스레드 등이 존재합니다.
    
</div>
</details>

<details>
<summary><b>프로세스 간 컨텍스트 스위칭 비용이 스레드의 컨텍스트 스위칭 비용보다 큰 이유가 무엇일까요?</b></summary>
<div markdown="1">
  
  프로세스 간 컨텍스트 스위칭 시에는 주소 공간 변경이 필요하고 PCB도 저장을 해야 합니다. 
    
  반면 스레드는 같은 주소 공간을 공유하여 스택과 레지스터만 변경하면 되기 때문에 전환 비용이 적습니다.
</div>
</details>

<details>
<summary><b>멀티스레딩을 사용하면 항상 성능이 좋아질까요?</b></summary>
<div markdown="1">

  항상 그런 것은 아닙니다. 
  
  CPU 코어 수보다 많은 스레드를 생성하면 각 코어에서 경합하는 스레드 수가 점점 많아지기 때문에 오버헤드가 발생해서 싱글 스레드보다도 성능이 저하될 수 있습니다.
    
</div>
</details>

<details>
<summary><b>멀티 스레딩은 실제로 여러 작업이 동시에 일어나는건가요?</b></summary>
<div markdown="1">
  아니요 그렇지 않습니다. 유저의 시선에서는 프로그램들이 동시에 실행되는 것처럼 보이지만, 실제로는 컨텍스트 스위칭이 매우 빠르게 일어나면서 부분적으로 조금씩 각자의 작업을 수행하는 것 입니다.
</div>
</details>

<details>
<summary><b>스레드를 동기화 한다는게 어떤 의미인가요?</b></summary>
<div markdown="1">
  스레드 동기화란, 여러 개의 스레드가 공유 자원에 안전하게 접근할 수 있도록 실행 순서를 조정하는 것을 의미합니다.
</div>
</details>

<details>
<summary><b>스레드를 동기화 해야하는 이유가 무엇일까요?</b></summary>
<div markdown="1">

  1. 여러 스레드가 공유 자원에 동시에 접근하면 스레드간 경쟁이 발생할 수 있습니다.
  2. 특정 스레드가 자원을 독점하는 경우가 생길 수 있습니다.

  - **<꼬리질문> 스레드 동기화 방식에 대해 아는대로 설명해보세요**
    
        1. 뮤텍스 - 한 번에 하나의 스레드만 공유 자원에 접근 가능.
        2. 세마포어 - 뮤텍스와 비슷하지만, 여러 개의 스레드가 동시에 접근 가능하도록 제한할 수 있음.
</div>
</details>

<details>
<summary><b>스레드의 컨텍스트 스위칭을 최소화 할 수 있는 방법에는 뭐가 있을까요?</b></summary>
<div markdown="1">

  1. 새로운 스레드를 매번 생성하는 대신, 미리 일정 수의 스레드를 만들어 놓고 재사용하는 스레드 풀을 사용하는 것입니다. 
  2. 코어 수에 맞는 적절한 스레드의 개수를 유지하는 것입니다.
</div>
</details>
