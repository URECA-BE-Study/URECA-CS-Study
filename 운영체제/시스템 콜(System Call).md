# 운영체제

운영체제는 컴퓨터 시스템의 자원을 효율적으로 관리하고, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임이다.

- **좁은 의미의 OS**: 커널을 의미하며, 컴퓨터가 켜진 후 항상 메모리에 상주하는 운영 체제의 핵심 부분  
- **넓은 의미의 OS**: 커널을 포함하여 다양한 유틸리티 프로그램까지 포괄하는 개념  

---

## 시스템 콜 (System Call)

시스템 콜은 사용자 프로그램이 운영체제 커널의 기능을 사용할 수 있도록 해주는 **인터페이스**이다.

- 사용자 모드에서 커널 모드로 전환하여 커널의 기능을 사용할 수 있게 한다.
- 응용 프로그램은 하드웨어에 직접 접근하지 않고, 시스템 콜을 통해 간접적으로 커널에게 요청한다.
- 시스템 콜은 보통 **API (Application Programming Interface)** 를 통해 간접적으로 사용된다 (예: C의 `read()`, `write()` 등).

### 시스템 콜이 중요한 이유

- **보안**: 사용자 프로그램이 커널 영역이나 하드웨어를 직접 제어할 수 없도록 차단
- **안정성**: 운영체제가 자원을 관리하므로, 프로그램 오류로 인한 시스템 전체의 불안정성을 줄임
- **자원 보호**: CPU, 메모리, 입출력 장치 등을 보호하며 공정한 분배 가능
- **추상화**: 복잡한 하드웨어 동작을 단순한 호출로 대체

---

## 커널 (Kernel)

운영체제의 핵심 부분으로 항상 메모리에 상주하며 다음과 같은 역할을 수행한다:

- **자원 관리**: CPU, 메모리, 장치 등의 자원을 효율적으로 분배
- **인터페이스 제공**: 사용자 프로그램이 시스템 기능을 사용할 수 있도록 인터페이스 제공
- **프로세스 및 메모리 관리**, **파일 시스템**, **입출력 처리**, **인터럽트 처리** 등의 기능 포함

> **쉘(Shell)**: 사용자 명령을 해석하여 커널에 전달하는 프로그램으로, 사용자와 커널 사이의 다리 역할을 한다.

---

## 이중 동작 모드 (Dual Mode Operation)

운영체제는 시스템 보호를 위해 두 가지 모드를 사용한다:

### 사용자 모드 (User Mode)

- 개발자가 만든 응용 프로그램이나 일반 소프트웨어가 실행되는 제한된 권한의 모드
- 시스템 자원(CPU, 메모리, I/O 등)에 직접 접근할 수 없으며, **커널을 통해서만 접근 가능**
- 하나의 응용 프로그램 오류가 시스템 전체에 영향을 주지 않도록 보호됨
- 시스템 자원을 사용하고 싶을 경우 반드시 **시스템 콜**을 통해 요청해야 함

> 사용자 모드는 **보안을 위해 자원 접근에 제한이 있는 격리된 환경**이다.

### 커널 모드 (Kernel Mode)

- 운영체제의 핵심 기능이 동작하는 모드로, 시스템 전체에 대한 **최고 권한을 가진 실행 환경**
- 모든 자원(CPU 제어, 메모리 접근, 장치 제어 등)에 접근 가능
- **디바이스 드라이버, 파일 시스템, 스케줄러, 메모리 관리자 등**이 이 모드에서 동작함
- 사용자 모드에서 시스템 콜이 호출되면, 해당 요청은 커널 모드로 전환되어 처리됨

> 커널 모드는 시스템 전체를 제어할 수 있는 권한을 갖기 때문에 **안정성과 보안이 매우 중요**하다.


### 모드 전환 (Mode Switching)

- 사용자 프로그램이 시스템 콜을 호출하면 커널 모드로 전환됨
- 커널은 요청을 처리하고 다시 사용자 모드로 전환
- 이 과정은 **인터럽트** 또는 **트랩(trap)** 을 통해 이루어진다

> **트랩(trap)**: 예외 또는 시스템 콜을 위해 의도적으로 발생시키는 소프트웨어 인터럽트

---

## 시스템 콜 처리 과정

1. 사용자 프로세스가 시스템 콜을 호출 (사용자 모드 → 커널 모드)
2. 커널은 호출된 시스템 콜 번호에 해당하는 서비스 루틴을 실행
3. 작업 완료 후 사용자 모드로 복귀

### 참고: 시스템 콜 번호

- 커널은 각 시스템 콜에 고유한 **번호**를 부여
- 사용자 프로그램은 이 번호를 통해 커널의 특정 루틴에 접근

---

## 시스템 콜 유형

### 1. 프로세스/스레드 제어
- 프로세스 생성, 종료, 대기
- 예: `fork()`, `exec()`, `wait()`, `exit()`

### 2. 파일 시스템 조작
- 파일 및 디렉토리 생성, 삭제, 열기, 닫기, 읽기, 쓰기
- 예: `open()`, `read()`, `write()`, `close()`, `unlink()`

### 3. 디바이스 입출력
- 하드웨어 장치와의 데이터 송수신
- 예: `read()`, `write()` (파일과 장치를 같은 방식으로 처리)

### 4. 정보 유지 및 관리
- 시스템 시간 확인, 사용자 정보, 시스템 설정 등
- 예: `getpid()`, `getuid()`, `time()`, `uname()`

### 5. 통신
- 프로세스 간 통신 (IPC), 네트워크 통신 등
- 예: `pipe()`, `shmget()`, `msgsnd()`, `recv()`, `send()`

### 6. 보안 및 접근 제어
- 파일 접근 권한 설정, 사용자 인증 등
- 예: `chmod()`, `chown()`, `umask()`

---

## 시스템 콜과 API의 관계

- 대부분의 프로그래밍 언어는 시스템 콜을 직접 호출하지 않고 **표준 라이브러리(API)** 를 통해 간접적으로 사용함
- 예를 들어, `printf()`는 내부적으로 `write()` 시스템 콜을 호출함

---

## 시스템 콜 호출 방법 (리눅스 기준)

- 리눅스에서는 `int 0x80` 명령어 또는 `syscall` 명령어를 통해 시스템 콜을 호출함
- 현대에는 보통 C 라이브러리를 통해 호출되므로 어셈블리 명령어를 직접 작성할 필요는 없음

---

## 요약

- 시스템 콜은 사용자 프로그램과 커널 간의 유일한 통신 수단
- 사용자 모드에서 커널 모드로의 안전한 전환을 제공
- 다양한 시스템 기능(프로세스, 파일, 통신, 메모리 등)에 접근 가능
- 대부분의 시스템 콜은 표준 API로 포장되어 있어, 개발자는 직접 호출하지 않아도 됨
