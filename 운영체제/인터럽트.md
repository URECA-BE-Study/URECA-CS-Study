# 인터럽트
## 1. 개념
- 예상치 못한 외부에서 발생한 이벤트로, OS가 CPU의 정상적인 프로그램 실행을 방해했다는 의미이다. 
- CPU가 프로그램을 실행 중일 때 예외 상황이 발생한 경우, CPU에게 알려 현재 실행 중인 작업을 중단하고 발생한 상황을 처리하도록 하는 것을 의미한다. 

<br>

> **인터럽트가 필요한 이유**
OS는 동시에 여러 작업을 처리할 수 없고, 사용자는 한 번에 여러 작업을 처리하기를 원한다. 대부분의 컴퓨터는 한 개의 CPU만 사용하기 때문에, 어떤 일을 처리하는 도중 우선순위가 급한 일을 처리할 필요가 있을 때 대처할 수 있는 방안이 필요하다. 이 대처 방안이 바로 인터럽트이다. 

<br><br>

## 2. 종류
### 1) 외부 인터럽트 (일반적인 인터럽트)
- CPU 외부로부터 인터럽트 요구 신호에 의해 발생되는 인터럽트이다.
- 하드웨어 컨트롤러가 CPU의 서비스를 요청하기 위해 발생시키는 인터럽트이다.
- Machine check interrupt
    - CPU의 기능적 오류
- I/O Interrupt
    - 입출력 장치가 데이터 전송을 요구하거나 전송이 끝나 다음 동작이 수행되어야할 경우
    - 입출력 데이터에 이상이 있는 경우

### 2) 내부 인터럽트 (Trap)
- CPU 내부에서 실행하면서 인터럽트에 걸리는 경우
- 컴퓨터의 내부 시스템에서 생성되는 인터럽트로, CPU 내부에서 자신이 실행한 명령이나 CPU의 명령 실행에 관련된 모듈이 변화하는 경우 발생한다.
- 프로그램 실행 중 프로그램 상의 처리 불가능한 오류나 이벤트를 알리기 위한 경우 발생하는데 이를 Trap 또는 예외라고 한다.
- Program check interrupt
    - Division by zero
    - Overflow/Underflow
    - 기타 Exception

### 3) 소프트웨어 인터럽트
- SVC interrupt로, 운영체제에게 제어권을 넘겨 해결하는 Supervisor Call이다.
- 시스템콜과 같은 맥락으로, 운영체제에 서비스를 요청하기 위해 인터럽트를 걸고 커널 모드로 전환하는 인터럽트이다.


> **인터럽트 분류 관점**
내부인터럽트에 소프트웨어 인터럽트를 포함하여 말하는 경우도 있다.
또한, 외부/내부 인터럽트를 HW/SW인터럽트라고 하기도 한다.
통상적으로 HW 인터럽트를 인터럽트, SW 인터럽트는 Trap이라는 용어를 사용한다. 

<br><br>

## 3. 인터럽트 처리 과정
1. 인터럽트 발생
2. 프로세스 중단 (커널 개입)
    - 프로세스의 정보르 PCB에 저장 (Context Saving)
3. 인터럽트 처리 (interrupt handling)
    - 인터럽트 발생장소, 원인 파악
    - 인터럽트 서비스할 것인지 결정
4. 인터럽트 서비스 루틴 호출 (interuupt service)
    - 인터럽트를 서비스하기로 결정했을 경우 진행

<br>

### 1) 인터럽트 플래그 (Interrupt Flag)
: 하드웨어 인터럽트를 받아들일지 무시할지 결정하는 플래그로, 0으로 설정하면 인터럽트 요청을 무시한다. 
- 모든 하드웨어 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아니다. 
- 막을 수 있는 것은 Maskable Interrupt, 막을 수 없는 것은 Non Maskable Interrupt라고 한다. 
- Non Maskable Interrupt는 치명적인 오류 발생 시 사용된다.

<br>

### 2) 인터럽트 핸들러 (Interrupt Service Routine, ISR)
: CPU가 실행하는 실제 인터럽트를 처리하는 루틴으로, 인터럽트 별로 필요한 작업을 수행할 수 있도록 정해져 있는 OS안의 코드이다. 
- 인터럽트 핸들러는 인터럽트 원인에 따라 각각 존재한다.
- OS의 코드 부분에는 각종 인터럽트별로 처리해야할 내용이 이미 프로그래밍되어 있다.
- 호출된 인터럽트 서비스 또한 하나의 프로세스이다. 따라서 서비스가 끝나면 ready 상태의 프로세스들이 올라온다. 

<br>

### 3) 인터럽트 벡터 테이블 (Interrupt Vector Table, IVT)
: 여러가지 인터럽트에 대해 해당 인터럽트 발생 시 처리해야 할 루틴의 주소를 보관하고 있는 테이블로, CPU에 존재한다. 
- 인터럽트 벡터 테이블에서 발생한 인터럽트를 검사한 후, 해당하는 인터럽트 서비스를 실행한다. 

> **인터럽트 벡터**
CPU가 수많은 서비스 루틴을 구분하기 위해 사용하는 벡터로, 인터럽트 벡터를 알면 인터럽트 서비스 루틴의 시작 주소를 알 수 있다. 

<br><br><br>

# Polling
## 1. 개념
- 하드웨어의 변화를 지속적으로 읽어들이며 이벤트의 수행여부를 주기적으로 검사하여 해당 신호를 받았을 때 이벤트를 실행한다.
- 하드웨어 장치의 상태를 수시로 체크하여 명령을 받을 수 있는지 확인한다. 

<br><br>

## 2. 폴링 동작 과정
1. 운영체제와 하드웨어간 상호작용한다.
    - 운영체제가 하드웨어 장치의 `상태 레지스터`를 읽음으로써 명령의 수신여부를 주기적으로 확인한다.
2. 운영체제가 `데이터 레지스터`에 데이터를 전달한다.
3. 운영체제가 `명령 레지스터`에 명령을 기록한다.
4. 폴링 반복문을 실행한다.
    - 운영체제는 하드웨어 장치가 특정 동작을 처리했는지 폴링 반복문을 돌며 기다린다.
    - 성공/실패 코드를 받는다. 

<br>

> **하드웨어 장치**
- 하드웨어 인터페이스(Interface) : 인터페이스를 통해 시스템 소프트웨어가 동작을 제어할 수 있도록 한다. 하드웨어 장치들은 특정한 상호 동작을 위한 방식과 명시적인 인터페이스를 가진다. 
    - `상태 레지스터 (Status Register)` : 하드웨어 장치의 현재 상태를 읽을 수 있는 레지스터이다. 
    - `명령 레지스터 (Command Register)` : 하드웨어 장치가 특정 동작을 하도록 요청할 때 사용하는 레지스터이다. 
    - `데이터 레지스터 (Data Register)` : 하드웨어 장치에 데이터를 주고받을 때 사용하는 레지스터이다.
- 내부 구조(Internals) : 시스템에게 제공하는 장치에 대한 추상화를 정의한다. 

<br><br>

## 3. 장점
- 구현이 쉽다.
- 우선순위 조정이 용이하다.
- 단순하고 예측이 가능하다.
- 빠른 하드웨어 장치에는 유리하다. (오버헤드가 적을 수 있기에)

<br><br>

## 4. 단점
- CPU를 계속 점유하여 자원 낭비가 심하다.
- 정확한 타이밍 보장이 어렵다.
- 주기 오차가 발생할 수 있다.
- CPU가 항상 깨어있어야 한다.
- CPU가 직접 일을 하기에 입출력 시간이 오래 걸린다.
- 장치가 응답하지 않아도 루프를 돌며 리소스를 계속 사용하기에 시스템 리소스가 낭비된다.

<br>

> **하드웨어 측면의 인터럽트**
CPU가 프로그램을 실행하는 중 특별한 처리가 필요한 경우 CPU에 알려 이를 처리한다. 운영체제는 디바이스에 폴링하는 대신 I/O를 요청시킨 프로세스를 블록시키고 CPU를 다른 프로세스에게 양도한다. 그 결과 하드웨어 인터럽트가 발생한다.
CPU연산과 I/O장치 작업을 중첩시켜 수행 가능하여 폴링보다 높은 CPU 사용률을 가진다.
Context Switching이 발생하기에 빠른 하드웨어 장치일 경우 폴링이 더 효과적이다.