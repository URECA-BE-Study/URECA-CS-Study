## 변하영

<details> 
<summary><b>고정 분할 방식과 가변 분할 방식의 주요 차이점과 각 방식의 단점은 무엇인가요?</b></summary>
<div markdown="1">

고정 분할 방식은 메모리를 미리 정해진 크기의 분할로 나누는 방식으로, 내부 단편화가 발생합니다. 반면에, 가변 분할 방식은 동적으로 크기를 조절할 수 있어 내부 단편화는 줄어들지만, 외부 단편화가 발생하여 압축 등 추가적인 관리가 필요합니다. 

</div>
</details>

<details> 
<summary><b>페이징과 세그먼테이션이 각각 내부/외부 단편화에 미치는 영향은 무엇인가요?</b></summary>
<div markdown="1">

페이징은 고정 크기의 페이지 단위로 메모리를 관리하기 때문에 외부 단편화가 발생하지 않지만, 페이지 크기보다 작은 마지막 블록에서는 내부 단편화가 발생할 수 있습니다. 반면에, 세그먼테이션은 가변 크기의 블록으로 관리되므로, 내부 단편화는 없지만 외부 단편화가 발생할 가능성이 큽니다. 

</div>
</details>

<details> 
<summary><b>페이지 크기가 커질 때와 작아질 때의 장단점을 비교해보세요. </b></summary>
<div markdown="1">

페이지 크기가 크면 페이지 테이블 크기가 줄어들어 메모리 관리 오버헤드가 감소하지만 내부 단편화가 증가할 수 있습니다. 반면에 페이지 크기가 작으면 내부 단편화는 줄어들지만, 페이지 테이블 크기가 커져서 메모리 관리 부담이 커집니다. 

</div>
</details>

<details> 
<summary><b>페이지 테이블이 너무 커지는 문제를 해결하기 위한 대표적인 기법들을 설명해주세요</b></summary>
<div markdown="1">

계층적 페이지 테이블은 페이지 테이블을 여러 단계로 나누어 관리하여 전체 크기를 줄이지만, 주소 변환 과정이 복잡해집니다. 해시 페이지 테이블은 해시 함수를 이용해 페이지 테이블을 압축하는 방식으로, 빠른 접근이 가능하지만 해시 충돌 관리가 필요합니다. inverted 페이지 테이블은 프로세스당 하나의 테이블이 아니라 시스템 전체에서 단일 페이지 테이블을 사용하여 메모리 사용을 줄이는 방식이지만, 페이지 검색 시간이 증가할 수 있습니다. 

</div>
</details>

<details> 
<summary><b>페이징에서의 TLB의 역할에 대해 설명해주세요</b></summary>
<div markdown="1">

TLB는 자주 사용되는 페이지 테이블 항목을 캐싱하여 주소 변환 속도를 향상시키는 역할을 합니다. TLB 미스가 발생하면 페이지 테이블을 메모리에서 직접 참조해야 하므로 주소 변환 속도가 느려집니다. 

</div>
</details>

<details> 
<summary><b>세그먼테이션을 사용할 때, 메모리 압축이 필요한 이유는 무엇인가요?</b></summary>
<div markdown="1">

세그먼테이션에서는 프로세스가 다양한 크기의 세그먼트를 가지므로, 프로세스가 종료될 때 불연속적인 자유 공간이 많이 생깁니다. 이 외부 단편화가 심해지면, 새로운 프로세스를 위한 연속적인 공간을 확보하기 어려워지므로 메모리를 재배열하여 조각난 공간을 합치는 압축이 필요합니다. 

</div>
</details>

<details> 
<summary><b>segmented paging이 필요한 이유는 무엇인가요?</b></summary>
<div markdown="1">

세그먼테이션은 외부 단편화 문제를 가지고, 페이징은 내부 단편화 문제를 가질 수 있습니다. segmented paging은 세그먼트마다 별도의 페이지 테이블을 두어 세그먼트 내부에서 페이징을 적용하는 방식으로, 세그먼테이션의 논리적 구조를 유지하면서도 페이지 단위로 메모리를 관리할 수 있어 단편화 문제를 완화할 수 있습니다. 

</div>
</details>

<br>

## 박상윤

<details> 
<summary><b>가변 분할 방식에서 사용되는 메모리 할당 알고리즘 3가지와 차이점을 설명하세요</b></summary>
<div markdown="1">

1. 최초 적합
  - 메모리에서 가장 처음 발견된 충분한 크기의 빈 공간에 프로세스를 할당하는 방식
2. 최적 적합
  - 프로세스가 들어갈 가장 작은 빈 공간을 찾아서 할당하는 방식
3. 최악 적합
  - 프로세스가 들어갈 가장 큰 빈 공간을 찾아서 할당하는 방식

</div>
</details>

<details> 
<summary><b>외부 단편화를 해결하기 위해 어떠한 방법을 사용할까요?</b></summary>
<div markdown="1">

메모리 압축 방법을 사용합니다.

이는 흩어진 프로세스를 한 곳으로 모아 빈 공간을 연속적인 하나의 큰 공간으로 재배치하는 방식입니다.

</div>
</details>

<details> 
<summary><b>내부 단편화를 해결하기 위해 어떠한 방법을 사용할까요?</b></summary>
<div markdown="1">

- 더 작은 페이지 크기 사용
  - 페이지 크기가 작아질수록 내부 단편화가 줄어들지만, **페이지 테이블 크기가 커지는 단점**이 있음

- 세그먼테이션(Segmentation) 사용
  - 프로세스를 논리적인 크기로 나누어 필요한 만큼 메모리를 할당하는 방식
  - 하지만, 외부 단편화가 발생할 수 있음

</div>
</details>

<details> 
<summary><b>논리 주소를 물리 주소로 변환해주는 친구는 누굴까요?</b></summary>
<div markdown="1">

메모리 관리 장치

</div>
</details>

<details> 
<summary><b>고정 분할 방식은 어떤 단편화 문제가 발생하나요?</b></summary>
<div markdown="1">

외부 단편화

</div>
</details>

<br>

## 신예지

<details> 
<summary><b>페이지와 세그멘테이션 기법을 왜 쓸까요?</b></summary>
<div markdown="1">

다중 프로그래밍 시스템에 여러 프로세스를 수용하기 위해 주기억장치를 동적 분할하는 메모리 관리 작업이 필요하기 때문

</div>
</details>

<details> 
<summary><b>연속 메모리 관리 기법 중 고정 분할과 동적 분할 각각에서 발생할 수 있는 문제를 말해주세요</b></summary>
<div markdown="1">

- 고정 분할(Fixed Partitioning): 내부 단편화(Internal Fragmentation)

- 동적 분할(Dynamic Partitioning): 외부 단편화(External Fragmentation)

</div>
</details>

<details> 
<summary><b>동적 분할에서는 외부 단편화를 해결하기 위해 Compaction이 있지만 실제로 잘 사용하지 않습니다. 왜 그럴까요?</b></summary>
<div markdown="1">

메모리 내의 프로세스를 이동시켜야 하기 때문에 **CPU와 메모리 I/O 비용**이 큼

실시간 시스템(Real-Time System)에서는 **예측 가능한 응답 시간(Response Time)이 중요**한데,

Compaction은 수행 시간이 일정하지 않고 오래 걸릴 수 있어 실시간 환경에서는 적절하지 않음

</div>
</details>

<details> 
<summary><b>고정 분할과 동적 분할을 합친 Buddy System이 있습니다. Buddy System의 과정을 설명해주세요</b></summary>
<div markdown="1">

동적 분할처럼 공간이 필요할 때 나누는데, 공간을 나눌 때 고정 분할처럼 정해진 규칙에 따라 공간을 나눔

정해진 규칙 → `2^(n-1)≤프로그램의 크기≤2^n` 으로 나눔

합칠 때도 같은 buddy끼리 합치므로 Compaction이 없음

But 여전히 Internal Fragmentation은 존재할 수 있음

</div>
</details>

<details> 
<summary><b>불연속 메모리 관리 기법인 페이징 기법과 세그먼트 기법의 주요 차이점에 대해 말해주세요</b></summary>
<div markdown="1">

페이징은 고정 사이즈의 작은 프로세스 조각인 페이지 단위로 나누고, 세그먼트는 서로 다른 크기를 가진 논리적 블록 단위로 나눔

</div>
</details>

<details> 
<summary><b>페이징 기법에서 Page와 Frame의 차이를 설명해주세요</b></summary>
<div markdown="1">

- 프레임: 물리 메모리를 고정된 블록 사이즈로 분할한 것
- 페이지: 논리 메모리를 프레임과 같은 크기로 분할한 것

</div>
</details>

<details> 
<summary><b>프레임 크기와 페이지 크기는 항상 같아야 하나요? 이유는?</b></summary>
<div markdown="1">

항상 같아야 함

**이유:**

1. **페이지와 프레임 크기가 다르면, 페이징 기법을 사용할 수 없음.**
- 가상 메모리는 페이지 단위로 나누고, 물리 메모리는 동일한 크기의 프레임으로 나눔.
- 만약 페이지 크기 ≠ 프레임 크기라면, 페이지를 프레임에 그대로 매핑할 수 없음.
2. **메모리 할당 및 관리가 복잡해짐.**
- 페이지 크기가 다르면, 단편화(Fragmentation) 문제가 더욱 심각해질 수 있음.
- 동일한 크기일 때 메모리 교체(페이지 교체 알고리즘)가 쉬움.

</div>
</details>

<details> 
<summary><b>다음 그림에서 1. 한 페이지의 크기는?
2. 한 프로그램 안에 최대 페이지 수는? 
3. 프로그램의 전체 크기는? </b></summary>
<div markdown="1">

1. 한 페이지의 크기: 2^10bit
2. 한 프로그램 안에 최대 페이지 수: 2^6bit
3. 프로그램의 전체 크기: 2^16bit

</div>
</details>

<br>

## 이소원

<details> 
<summary><b>페이지 크기는 사용자가 임의로 설정할 수 있나요?</b></summary>
<div markdown="1">

일반적으로 설정할 수 없습니다.

페이지 크기의 선택은 성능, 메모리 효율성, 단편화 등과 관련된 여러 요소를 고려하여 운영체제와 하드웨어(주로 CPU, MMU) 결정합니다.

</div>
</details>

<details> 
<summary><b>페이지와 프레임의 차이에 대해 설명해주세요.</b></summary>
<div markdown="1">

페이지는 프로세스의 논리 주소 공간을 일정한 블록의 크기로 나눈 것이고, 프레임은 물리 메모리를 페이지 크기와 동일한 블록으로 나눈 것입니다.

</div>
</details>

<details> 
<summary><b>외부 단편화와 내부 단편화의 차이를 설명해주세요.</b></summary>
<div markdown="1">

- 외부 단편화
  - 세그멘테이션과 같이 가변 블록을 사용할 때 발생
  - 가변 크기의 메모리 블록을 할당하고 해제하는 과정에서 빈 공간이 여러군데 나뉘어 생기기 때문에 발생
  - 전체 메모리에는 충분한 공간이 있지만, 연속된 공간이 부족하여 큰 프로세스를 할당하지 못하는 경우를 말한다.
 
- 내부 단편화
  - 페이징과 같이 고정 크기 블록을 사용할 때 발생
  - 실제로 필요한 메모리보다 더 큰 크기의 고정 크기 메모리 블록(ex.페이지)이 할당되어 메모리가 낭비될 때 발생

</div>
</details>

<details> 
<summary><b>Segmentation Fault는 어떤 경우에 발생하나요? (c/c++)</b></summary>
<div markdown="1">

Segmentation Fault는 주로 프로세스가 세그먼트 내에서 허용되지 않는 메모리 영역을 접근하려 할 때 발생합니다.

1. 배열의 경계를 벗어나거나
2. 스택 영역을 초과하여 접근하거나
3. null 포인터를 역참조하는 경우에 발생합니다.

</div>
</details>

<details> 
<summary><b>페이징 기법을 통해 어떻게 단편화를 해결할 수 있나요?</b></summary>
<div markdown="1">

프로그램이 사용하는 메모리 공간이 연속된 위치에 있어야 한다면, 외부 단편화 문제가 발생할 수 있습니다.

페이징 기법은 프로그램의 메모리를 작은 조각(페이지)로 나눠서 물리 메모리에서 꼭 연속된 위치가 아니여도 실행할 수 있도록 하는 방법입니다.

페이징 기법을 통해 프로그램을 작은 조각으로 나누어 물리 메모리의 빈 공간에 나눠서 배치가 가능하다. 따라서 연속된 큰 공간이 없어도 페이징 기법을 통해 작은 빈 공간들을 활용할 수 있어 외부 단편화를 해결할 수 있다.

</div>
</details>

<details> 
<summary><b>세그멘테이션 페이징(Segmentation Paging) 기법에 대해 설명해주세요.</b></summary>
<div markdown="1">

하나의 프로그램을 세그먼트로 나눈 뒤 해당 세그먼트가 실제 물리 메모리에 적재될 때 페이징처럼 일정한 크기로 나누어 적재하는 기법입니다

</div>
</details>

<br>

## 김수훈

<details> 
<summary><b>페이징과 세그멘테이션을 쓰는 이유가 무엇인가요?</b></summary>
<div markdown="1">

다중 프로그래밍 시스템에 여러 프로세스를 수용하기 위해 주기억장치를 동적 분할하는 메모리 관리 작업이 필요하기 때문입니다.

</div>
</details>

<details> 
<summary><b>내부 단편화와 외부 단편화가 무엇인가요?</b></summary>
<div markdown="1">

- 외부 단편화: 메모리 공간 중 사용하지 못하게 되는 일부분. 물리 메모리(RAM)에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어 있을때 발생한다고 볼 수 있다.
- 내부 단편화: 프로세스가 사용하는 메모리 공간 에 포함된 남는 부분. 예를들어 메모리 분할 자유 공간이 10,000B 있고 Process A 가 9,998B 사용하게되면 2B 라는 차이 가 존재하고, 이 현상을 내부 단편화라 칭한다.

</div>
</details>

<details> 
<summary><b>페이징과 세그멘테이션에서 각 어떤 단편화 문제가 생기고, 왜 생기는지 설명해주세요.</b></summary>
<div markdown="1">

### 페이징에서의 단편화

- 내부 단편화 문제가 주로 발생합니다.
- 페이징은 메모리를 고정된 크기의 페이지로 나누는데, 프로세스 크기가 페이지 크기의 배수가 아닐 경우 마지막 페이지에 사용되지 않는 공간이 생깁니다. 예를 들어 페이지 크기가 4KB인데 프로세스가 10KB라면, 3개의 페이지(12KB)가 할당되고 마지막 페이지에서 2KB의 내부 단편화가 발생합니다.

### 세그멘테이션에서의 단편화

- 외부 단편화 문제가 주로 발생합니다.
- 세그멘테이션은 논리적 단위(코드, 데이터, 스택 등)에 따라 메모리를 가변 크기로 할당합니다. 프로세스가 종료되면 다양한 크기의 빈 공간이 메모리 전체에 흩어져 있게 되어, 새로운 세그먼트를 위한 연속된 충분한 공간을 찾기 어려워집니다.

</div>
</details>

<details> 
<summary><b>세그멘테이션 방식에서 외부 단편화를 해결하기 위한 대표적인 방법은?</b></summary>
<div markdown="1">

압축 기법을 사용하여 메모리 내 분산된 세그먼트를 하나로 모을 수 있어 외부 단편화를 해결할 수 있습니다.

</div>
</details>

<details> 
<summary><b>페이징과 세그멘테이션을 비교할 때, 각 기법이 주로 사용하는 테이블과 해당 테이블의 역할을 설명해주세요.</b></summary>
<div markdown="1">

페이징에서는 페이지 테이블을 사용하며, 이는 논리 주소의 페이지 번호를 물리 메모리의 프레임 번호로 변환하는 역할을 한다.

세그멘테이션에서는 세그먼트 테이블을 사용하며, 각 세그먼트의 시작 주소와 크기를 저장하고, 논리 주소를 물리 주소로 변환하는 데 활용된다.

</div>
</details>
