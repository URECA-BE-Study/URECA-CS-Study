# 인덱스(Index)

## 1. 인덱스란?
인덱스(Index)는 데이터베이스에서 검색 성능을 향상시키기 위한 자료구조이다.  
- 특정 컬럼을 기반으로 테이블의 데이터를 빠르게 찾을 수 있도록 추가적인 메모리 공간을 활용한다.  
- 인덱스는 테이블과 별도로 관리되며, 데이터를 정렬된 구조로 저장하여 검색을 최적화한다.  
- 컬럼 값과 물리적 주소를 `(Key, Value)` 형태로 저장하여 검색 속도를 높인다.  

## 2. 인덱스의 장단점

### 장점
- **검색 속도 향상**: 테이블 전체를 검색하는 것보다 빠르게 데이터를 조회할 수 있다.  
- **ORDER BY, GROUP BY 성능 개선**: 인덱스를 사용하면 정렬과 그룹화 연산을 더 빠르게 수행할 수 있다.  
- **JOIN 성능 최적화**: 테이블 간 조인 연산 시 인덱스를 활용하여 효율적인 검색이 가능하다.  

### 단점
- **추가적인 저장 공간 필요**: 인덱스 데이터를 저장하기 위해 추가적인 공간이 필요하다.  
- **데이터 변경 시 오버헤드 발생**:  
  - `INSERT`: 새로운 데이터를 추가하면 인덱스를 갱신해야 한다.  
  - `DELETE`: 삭제된 데이터의 인덱스를 정리해야 한다.  
  - `UPDATE`: 인덱스가 걸린 컬럼의 값이 변경되면 인덱스를 재구성해야 한다.  
- **과도한 인덱스 사용 시 성능 저하**: 불필요한 인덱스가 많아지면 데이터 변경 작업(쓰기 연산)의 비용이 증가한다.  

---

## 3. 인덱스의 자료구조

### 1) B+Tree (Balanced Plus Tree)
대부분의 관계형 데이터베이스(RDBMS)에서 사용하는 대표적인 인덱스 구조이다.  
- 데이터를 **정렬된 상태**로 유지하며, **검색, 삽입, 삭제가 빠르게 수행**된다.  
- 리프 노드(Leaf Node)들끼리 **Linked List 형태**로 연결되어 있어 범위 검색(`BETWEEN`, `ORDER BY`)에 유리하다.  
- 이진 탐색(Binary Search) 방식으로 동작하며, 평균 탐색 시간은 **O(log N)**이다.  

```sql
CREATE INDEX idx_user_name ON users(name);
```
위 코드는 users 테이블의 name 컬럼에 인덱스를 생성하여 검색 성능을 향상시킨다.

## 2) Hash Index (해시 인덱스)

Hash Index는 **Key-Value 형태**로 저장되며, 특정 키에 대해 빠르게 값을 찾을 수 있는 인덱스 구조이다.

- `=` 연산(정확한 값 일치 검색)에 최적화되어 있으며, 빠른 검색 속도를 제공한다.
- 그러나 데이터가 **정렬되지 않기 때문에**, 부등호(`<`, `>`, `BETWEEN`) 연산이 불가능하다.

## 4. 클러스터드 인덱스 vs. 비클러스터드 인덱스

### 인덱스 유형 비교

| 인덱스 유형 | 설명 |
|------------|--------------------------------------------------|
| **클러스터드 인덱스 (Clustered Index)** | 데이터를 정렬된 상태로 저장하며, 테이블 자체가 인덱스 역할을 한다. |
| **비클러스터드 인덱스 (Non-Clustered Index)** | 실제 데이터와 별도로 인덱스 테이블을 유지하며, 물리적 데이터 주소를 저장한다. |

---

### 클러스터드 인덱스 특징
- 한 **테이블당 하나만 생성 가능**하다.  
- 테이블의 **데이터 자체가 정렬된 상태**로 저장된다.  
- **검색 속도가 빠르지만**, 삽입(INSERT)·삭제(DELETE) 시 **데이터 재정렬이 필요**하여 성능이 저하될 수 있다.  

---

### 비클러스터드 인덱스 특징
- 한 **테이블에 여러 개 생성 가능**하다.  
- 실제 데이터와 **별도로 인덱스 테이블을 유지**하며, **물리적 데이터 주소를 저장**한다.  
- 데이터 저장 순서와 무관하며, **검색 시 한 단계를 더 거쳐야 하므로 속도가 다소 느릴 수 있다.**  

---

### 클러스터드 인덱스 vs. 비클러스터드 인덱스 예제

```sql
-- 클러스터드 인덱스 (기본키에 자동 생성됨)
CREATE TABLE users (
    id INT PRIMARY KEY,  -- 자동으로 클러스터드 인덱스 적용
    name VARCHAR(50)
);
```

```sql
-- 비클러스터드 인덱스 생성
CREATE INDEX idx_name ON users(name);
```
위 코드에서
- id 컬럼은 PRIMARY KEY로 설정되어 자동으로 클러스터드 인덱스가 생성된다.
- name 컬럼에는 비클러스터드 인덱스가 별도로 생성되어, 검색 성능을 향상시킬 수 있다.

## 5. 인덱스와 성능 최적화

### 인덱스를 사용할 때 고려해야 할 점
- `WHERE` 절에서 **자주 사용하는 컬럼**에 인덱스를 생성하면 검색 성능이 향상된다.
- `ORDER BY`, `GROUP BY` 연산을 수행할 때 인덱스를 활용하면 성능이 최적화될 수 있다.
- `JOIN` 시 **외래키(Foreign Key)** 컬럼에 인덱스를 생성하면 조인 연산의 성능을 개선할 수 있다.
- **너무 많은 인덱스를 생성하면 쓰기(INSERT, UPDATE, DELETE) 성능이 저하될 수 있으므로 주의해야 한다.**

---

## 6. 결론

- 인덱스는 **검색 성능을 최적화하는 핵심적인 기능**이지만, **삽입(INSERT)·삭제(DELETE)·수정(UPDATE) 시 오버헤드**가 발생할 수 있다.  
- **불필요한 인덱스가 많아지면** 데이터 변경(쓰기) 작업의 성능이 저하될 수 있다.  
- 따라서 **읽기(조회) 성능과 쓰기(삽입·수정·삭제) 성능을 균형 있게 조절하는 전략이 필요하다.**

## 7. 인덱스 업데이트 및 정리

### 1) MySQL에서 인덱스 업데이트 방식

MySQL에서 인덱스가 업데이트되는 방식은 **사용 중인 스토리지 엔진**에 따라 다르다.  
가장 많이 사용되는 **InnoDB 스토리지 엔진**에서는 다음과 같은 방식으로 인덱스를 업데이트한다:

- 데이터가 변경되면 해당 인덱스 엔트리도 함께 변경된다.
- **변경 버퍼(Change Buffer)** 를 사용하여 인덱스 업데이트를 최적화한다.
- 변경 버퍼는 **인덱스 페이지가 메모리에 없을 때** 임시 저장 공간 역할을 하며, 이후 백그라운드 스레드에 의해 인덱스에 병합된다.
- 인덱스 정리는 대부분 자동으로 수행되며, 특정 인덱스 페이지가 읽힐 때 병합 과정이 함께 진행된다.

### 2) InnoDB의 자동 정리 메커니즘

InnoDB는 **MVCC(다중 버전 동시성 제어, Multi-Version Concurrency Control)** 를 사용하여 이전 버전의 데이터를 유지한다.  
이전 데이터는 **Undo Logs**에 저장되며, 필요 없어진 데이터는 **Purge(정리) 작업**을 통해 제거된다.

InnoDB는 백그라운드에서 자동으로 정리 작업을 수행하는 여러 스레드를 운영한다:
- **Purge 스레드**: 더 이상 필요 없는 이전 레코드를 삭제한다.
- **Change Buffer 병합 스레드**: 변경된 인덱스를 실제 인덱스에 병합한다.

일반적으로 **시스템이 유휴 상태일 때** 정리 작업이 활발하게 수행된다.

### 3) MySQL에서 인덱스 최적화 및 정리 방법

MySQL은 PostgreSQL의 `VACUUM`과 같은 명령어는 없지만, 다음과 같은 명령어와 설정을 활용하여 인덱스를 정리할 수 있다:

#### **1. OPTIMIZE TABLE**
테이블을 최적화하고 인덱스를 재구성하여 **삭제된 레코드로 인한 단편화를 줄이는 역할**을 한다.
```sql
OPTIMIZE TABLE 테이블명;
```

### 4) 결론

- **MySQL(InnoDB)** 는 **변경 버퍼(Change Buffer)와 Purge(정리) 작업을 통해 자동으로 인덱스를 관리**한다.  
- **OPTIMIZE TABLE**을 사용하여 **수동으로 인덱스 정리를 수행할 수 있다**.  
- 필요에 따라 **InnoDB의 Purge 관련 설정을 조정하여** 인덱스 정리 및 성능 최적화를 진행할 수 있다.  
- **대부분의 경우 MySQL이 자동으로 정리 작업을 수행하므로, 특별한 관리가 필요하지 않지만**, 대규모 트랜잭션 환경에서는 주기적으로 인덱스 최적화를 고려해야 한다.  

