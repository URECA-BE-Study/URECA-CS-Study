## 신예지

<details>
<summary><strong>인덱스를 사용하면 항상 성능이 좋을까요?</strong></summary>

- X

- **INSERT, UPDATE, DELETE 성능 저하**
INDEX 를 생성하게 되면 INSERT, DELETE, UPDATE 쿼리문을 실행할 때 별도의 과정이 추가적으로 발생합니다. INSERT 의 경우 INDEX 에 대한 데이터도 추가해야 하므로 그만큼 성능에 손실이 따릅니다. DELETE 의 경우 INDEX 에 존재하는 값은 삭제하지 않고 사용 안한다는 표시로 남게 됩니다. 따라서 인덱스에서 삭제된 공간이 비효율적으로 관리될 가능성이 있습니다.
- **데이터 특성에 따라 인덱스가 오히려 비효율적일 수 있음**
남/녀 두 가지 값만 존재 → 인덱스를 검색해도 결국 테이블을 다시 조회해야 함(디스크 I/O 증가)

<br>

### **2. 데이터 특성에 따라 인덱스가 비효율적일 수 있음**
- 예를 들어, **성별(남/녀)과 같이 값의 종류가 적은 컬럼**은  
  **인덱스를 검색해도 결국 테이블을 다시 조회해야 하므로 성능이 저하**될 수 있다.  
</details>

<details>
<summary><strong>인덱스를 사용하면 좋은 상황을 말해주세요</strong></summary>

- `WHERE` 절에서 **자주 사용되는 컬럼**  
- **외래키(Foreign Key)가 사용되는 컬럼**  
- `JOIN`에 **자주 사용되는 컬럼**  
</details>

<details>
<summary><strong>B-Tree와 B+Tree의 차이에 대해 설명해주세요</strong></summary>

B-Tree는 내부 노드와 리프 노드에 데이터를 저장하여 검색이 빠르지만, 범위 검색(순차 검색)에 비효율적입니다. 
B+Tree는 리프 노드에만 데이터를 저장하고, 내부 노드는 탐색을 위한 키와 포인터만 유지하여 범위 검색에 최적화되어 있습니다.
</details>

<details>
<summary><strong>수정이 잦은 테이블에서 인덱스를 사용하면 왜 성능이 저하될까요?</strong></summary>

인덱스에는 UPDATE 작업이 따로 없습니다. 

인덱스를 제거하지 않고 '**사용하지 않음**'으로 남겨둔 후 새로운 인덱스를 추가하기 때문에 수정 작업이 많은 경우 2배의 작업이 소요되고 데이터에 비해 과도하게 인덱스 커집니다.

수정이 잦으면 인덱스 트리가 계속 변경되어 유지 비용이 증가하고, 페이지 분할(Split)과 병합(Merge)로 인해 추가적인 성능 저하가 발생할 수 있습니다.
</details>

<details>
<summary><strong>기본키는 인덱스일까요?</strong></summary>

기본키는 인덱스가 될 수 있지만, 기본키가 반드시 인덱스인 것은 아닙니다. 
하지만 일반적으로 기본키 열에는 인덱스가 자동으로 생성되어 기본키의 고유성과 검색성능을 보장하는데 사용됩니다.
</details>

<details>
<summary><strong>인덱스가 데이터의 물리적 저장에 영향을 미칠까요?</strong></summary>

- **클러스터형 인덱스(Clustered Index)**: 인덱스가 데이터의 물리적 저장 순서에 영향을 줌 (MySQL InnoDB의 PK 인덱스).
- **비클러스터형 인덱스(Non-Clustered Index)**: 데이터는 원래 테이블에 있고, 인덱스는 별도로 관리됨.

즉, 클러스터형 인덱스는 데이터의 물리적 정렬에 영향을 미치지만, 비클러스터형 인덱스는 영향을 미치지 않습니다.
</details>

<details>
<summary><strong>B+Tree가 B+Tree가 B-Tree보다 성능이 항상 더 좋을까요?</strong></summary>

아니요. B+Tree는 범위 검색과 정렬에 유리하지만, 특정 키 검색에서는 B-Tree가 더 빠를 수도 있습니다.
</details>

---

## 이소원

<details>
<summary><strong>어떤 경우에서 index를 사용하면 좋을까요?</strong></summary>

1. 검색이 자주 이루어지는 경우 ex) where 에 특정 조건을 사용하는 경우
2. 범위 검색이 많은 경우
3. 정렬이나 그룹화 연산이 자주 발생하는 경우
4. 대량의 데이터가 삽입 / 삭제 되는 경우
5. 고유한 값을 기준으로 데이터 접근이 자주 이루어지는 경우
6. 데이터가 크고 특정 칼럼에 대한 반복적인 조회가 이루어지는 경우 
</details>

<details>
<summary><strong>해시 테이블 대신 b-tree를 사용하는 이유는?</strong></summary>

SELECT 질의의 조건에는 부등호(<>) 연산도 포함이 됩니다. hash table 을 사용하게 된다면 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생합니다. 
따라서 동등 연산(=)에 특화된 hashtable은 데이터베이스의 자료구조로 적합하지 않습니다.
</details>

<details>
<summary><strong>기본키는 인덱스라고 할 수 있을까요?</strong></summary>

아니요.

기본키는 인덱스를 자동으로 생성하지만, 모든 인덱스가 기본키는 아닙니다. 기본키는 데이터의 유일성을 보장하는 제약조건이고, 인덱스는 성능 최적화의 도구입니다.

- 기본키는 테이블의 각 행을 유일하게 식별하기 위한 제약조건이자, 자동으로 인덱스가 생성되는 특성을 가집니다.
- 인덱스는 특정 컬럼에 대해 검색 성능을 개선하기 위한 자료구조로, 기본키 외에도 다른 컬럼에도 인덱스를 생성할 수 있습니다.
</details>

<details>
<summary><strong>인덱스가 데이터의 물리적 저장 순서에 항상 영향을 미칠까요?</strong></summary>

항상 x

데이터가 물리적으로 저장되는 방식은 일반 테이블 방식과 클러스터형 방식에 따라 다릅니다.

- 일반 테이블 방식
    
    대부분 DBMS 방식인 일반 테이블 방식에서는 별도의 인덱스를 생성하고, 별도의 인덱스 테이블로 만들어 실제 데이터를 참조하기 때문에 실제 테이블의 물리적 저장 위치에 영향을 미치지 않습니다.
    
- 클러스터형 인덱스
    - primary key에 인덱스를 적용 → primary key 값이 비슷한 레코드끼리 묶어서 저장
    (primary key는 행마다 고유한 값을 가지고 null 값을 가질 수 x)
    - 인덱스가 적용된 primary key 속성에 대해 물리적 위치 저장
    - 따라서 이때는 Primary 키 값이 변하게 되면 속성 값이 변하여 물리적 위치가 변경된다.
</details>

<details>
<summary><strong>왜 인덱스를 사용하면 병행성이 줄어들까요?</strong></summary>

**왜 인덱스를 사용하면 병행성이 줄어드나요?**  
인덱스를 사용하면 병행성이 줄어드는 이유는 인덱스 갱신 작업이 동시에 일어날 때 동기화 문제가 발생하기 때문입니다.

1. 인덱스 수정: 데이터가 삽입, 삭제, 업데이트 될 때, 인덱스도 함께 수정되어야 합니다. 이 과정에서 데이터와 인덱스를 동시에 수정하는 작업이 일어나는데, 여러 트랜잭션이 동시에 인덱스를 수정하려 할 때 락(lock)이 걸려서 다른 트랜잭션들이 기다려야 할 수 있습니다.
2. 락 경합: 인덱스는 특정 키 값에 대해 정렬된 구조로 유지되기 때문에, 여러 트랜잭션이 동시에 같은 인덱스 페이지를 수정하려고 하면, 해당 페이지에 락이 걸려 다른 트랜잭션이 대기해야 합니다. 이로 인해 동시에 작업을 처리할 수 있는 병행성이 떨어집니다.

따라서, 인덱스를 사용하면 성능이 향상되지만, 동시에 데이터 수정에 관련된 락 경합이 발생하여 병행성이 줄어드는 현상이 생깁니다.
</details>

---

## 변하영

<details>
<summary><strong>인덱스를 사용하면 성능이 무조건 향상될까?</strong></summary>

아닙니다. 

인덱스는 읽기 성능은 향상시키지만, 쓰기 성능을 저하시킬 수 있습니다. 인덱스는 데이터가 변경될 때 같이 갱신되어야 하기 때문입니다. 

또한, 데이터 중복도가 높거나 데이터의 양이 작은 테이블에서는 풀 테이블 스캔이 더 효율적일 수 있습니다.  
</details>

<details>
<summary><strong>해시 테이블 기반 인덱스 구현은 왜 범위 검색에 적합하지 않은가?</strong></summary>

내부적으로 해시 함수가 적용된 값만 저장되어 있고 데이터가 정렬되어 있지 않으므로 연속된 데이터 검색이 불가능합니다. 
</details>

<details>
<summary><strong>해시 테이블이 잘 사용되지 않는 이유가 무엇일까요?</strong></summary>
  
해시 함수의 특성상 속성 값을 그대로 검색해야 해서 검색하려는 값을 온전히 입력할때만 사용할 수 있습니다. 
</details>

<details>
<summary><strong>B-Tree가 아니라 B+Tree가 데이터베이스 인덱스로 더 많이 사용되는 이유는 무엇일까?</strong></summary>

B-Tree는 모든 노드에 데이터를 저장하지만, B+Tree는 단말 노드에만 데이터를 저장합니다. 
또한, B+Tree는 단말 노드끼리 연결 리스트로 연결되어 있어 범위 검색이 빠릅니다 .
</details>

<details>
<summary><strong>외래키에 인덱스를 반드시 추가해야 할까?</strong></summary>

반드시 그런 것은 아니지만, JOIN 연산이나 참조 무결성 검사를 빠르게 수행하려면 인덱스를 추가하는 것이 좋습니다. 

부모 테이블에서 자식 테이블을 조회할 일이 많다면, 외래키 컬럼에 인덱스를 추가했을 때 성능이 향상됩니다.
</details>

<details>
<summary><strong>Primary Index와 Secondary Index의 차이점은 무엇일까?</strong></summary>

Primary Index는 primary key에 자동으로 생성되는 인덱스이며, 테이블 당 하나만 존재합니다.

반면에 Secondary Index는 다른 컬럼에 수동으로 생성하는 것으로, 여러 개 만들 수 있습니다.
</details>

<details>
<summary><strong>Clustered Index와 Non-clustered Index의 차이가 무엇일까?</strong></summary>

clustered Index는 인덱스가 적용된 컬럼 값에 따라 데이터가 물리적으로 정렬됩니다. 즉, 레코드의 실제 저장 순서가 인덱스 순서와 일치합니다. 

반면에, non-clustered Index는 별도의 인덱스 테이블을 만들어 실제 데이터 테이블의 행을 참조합니다. 

이 때문에 clustered Index는 데이터가 많을수록 성능이 좋지만, 변경이 자주 발생하면 정렬 유지 비용이 큽니다.
![image](https://github.com/user-attachments/assets/049a8574-3f1b-4dcf-8292-d421692fd42f)
![image](https://github.com/user-attachments/assets/3bf0ef13-22a3-4e9c-b1cb-7808e915cde9)


</details>

<details>
<summary><strong>인덱스를 사용하기 적합한 상황과 아닌 상황에 대해 이야기해주세요</strong></summary>

인덱스를 사용하기 좋은 경우는 where절에서 자주 사용하는 column일 때, 외래키가 사용되는 column일 때, join에 자주 사용되는 column일 때가 있습니다. 

반면에 인덱스 사용을 피해야 하는 경우는 데이터 중복도가 높은 column일 때, DML이 자주 일어나는 column일 때가 있습니다.
</details>

---

## 김수훈

<details>
<summary><strong>DB에서 사용되는 인덱스에 대해 설명해주세요</strong></summary>

인덱스는 테이블을 처음부터 끝까지 검색하지 않고, 미리 정렬된 자료구조를 검색해서 해당 데이터의 테이블 위치를 빠르게 찾는 방법입니다. 
책의 색인과 유사한 개념으로, 원하는 정보를 빠르게 찾기 위한 데이터베이스의 핵심 구조입니다.
</details>

<details>
<summary><strong>인덱스를 사용하지 않으면 어떤 안좋은 점이 있나요?</strong></summary>

인덱스를 사용하지 않으면 데이터 레코드들이 순서 없이 저장되기 때문에, 특정 데이터를 찾기 위해 Full Scan 방식을 사용해야 합니다. 
이 경우 데이터베이스는 테이블의 모든 레코드를 하나씩 검사해야 하므로, 특히 대용량 테이블에서는 쿼리 성능이 현저히 저하됩니다. 
데이터가 많을수록 검색 시간은 선형적으로 증가하게 됩니다.

</details>

<details>
<summary><strong>실제 데이터베이스에서 해시 테이블이 아닌 B+트리를 사용하는 이유가 무엇인가요?</strong></summary>

O(1)로 접근할 수 있는 또 다른 테이블인 Hash Table을 쓰지 않는 이유는, 
Hash Table은 동등(=)연산에 특화 되어 있지만 데이터베이스에서는 부등호 연산이 자주 사용되기 때문에 적합하지 않습니다.
</details>

<details>
<summary><strong>B-트리가 아닌 B+트리를 사용하는 이유를 각 트리의 특성과 함께 설명해보세요.</strong></summary>

B-tree는 모든 노드에 key와 data를 담지만 B+ tree는 내부 노드에는 key만 담아두고, 리프 노드에만 key와 data를 저장하며 리프 노드끼리는 linked list를 사용합니다. 

따라서 B-tree는 범위 검색 시 모든 노드를 검사해야 할 수도 있습니다. 

반면에 B+ Tree는 리프노드에 모든 데이터가 있으므로 한 번의 선형 탐색만 하면 되기에 B+트리를 사용합니다.
</details>

<details>
<summary><strong>보통 인덱스는 어느 경우(컬럼)에 사용할까요?</strong></summary>

- 규모가 큰 테이블
- 특정 열에 대해 많은 종류의 값을 가지고 있는 컬럼(Cardinality가 높은 컬럼)
- 조인 연산의 성능을 향상시키기 위해 외래 키에 인덱스를 사용
</details>

<details>
<summary><strong>성별과 같은 boolean 컬럼에도 인덱스를 사용하는 것이 좋을까요?</strong></summary>
  
그렇지 않습니다. 
인덱스는 특정 열에 대해 중복이 적은, 즉 cardinality가 높은 컬럼에 사용하는 것이 좋기 때문에 값이 2개밖에 존재하지 않는 해당 경우에는 적절하지 않습니다.
</details>

<details>
<summary><strong>모든 요소에 인덱스를 사용하지 않는 이유는 무엇일까요?</strong></summary>

**모든 컬럼에 인덱스를 걸면 성능이 저하될 수 있음**  

첫번째로, DB 리소스와 메모리 자원을 낭비하게 됩니다.

모든 요소에 인덱스를 걸 경우 DB에서의 추가 쓰기 작업과 추가 메모리 공간이 필요하게 되고, 사용하지 않는 인덱스에 의한 메모리 점유도 일어나게 됩니다.

두번째로, 인덱스의 단점인 정렬상태를 유지해야하는 점에서 DB성능을 저하시킵니다.

데이터의 생성, 변경작업이 일어날 때 INDEX값을 재정렬해야하고, 원본테이블과 index테이블 두 군데를 수정하고 재정렬해야하므로 DB에 악영향을 미치게 됩니다.
</details>

---

## 박상윤

<details>
<summary><strong>인덱스를 사용함으로써 희생되는 기능은?</strong></summary>

INSERT, UPDATE, DELETE 데이터를 추가 및 삭제할때마다 인덱스 재정렬이 필요
</details>

<details>
<summary><strong>인덱스를 사용하면 조회가 빠른데, 그럼 전부 인덱싱을 해놓는 것이 좋을까요?</strong></summary>

전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져 역효과를 불러일으킬 수 있습니다. 
</details>

<details>
<summary><strong>레코드를 대표하는 칼럼으로 만들어진 인덱스를 무엇이라 하나요?</strong></summary>

프라이머리 키
</details>

<details>
<summary><strong>Hash 인덱스의 장점과 단점은 무엇일까요</strong></summary>

Hash 인덱스 알고리즘은 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원하지만, 
데이터 값을 변형해서 인덱싱하기 때문에 값의 일부만 검색하거나 범위를 검색할 때는 해시 인덱스를 사용할 수 없습니다.
</details>

<details>
<summary><strong>B-Tree의 구조는 어떻게 될까요?</strong></summary>

**최상위에 하나의 루트 노드**가 존재하고 **그 하위에 자식 노드**가 붙어 있는 형태입니다.

트리 구조의 가장 하위에 있는 노드를 **리프 노드**라고 하고, 트리 구조에서 루트 노드도 아니고 리프 노드도 아닌 중간의 노드를 **브랜치 노드라**고 합니다.
</details>

<details>
<summary><strong>인덱스의 리프 노드는 어떤 값을 가지고 있을까요?</strong></summary>

실제 데이터 레코드를 찾아가기 위한 주소값을 가지고 있습니다.
</details>

