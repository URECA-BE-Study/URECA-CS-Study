## 김수훈
<details>
<summary><strong>트랜잭션의 성질 ACID 중 일관성(consistency)에 대해 간단히 설명하고, 일관성이 지켜지는 예시를 송금 예시 제외하고 하나만 들어보세요.</strong></summary>
<div>

  - 데이터베이스의 상태가 트랜잭션 실행 전과 실행 후에도 항상 올바른 상태(유효한 데이터)로 유지되는 것을 의미합니다.
  - 즉,잘못된 데이터가 저장되지 않도록 보장하는 개념입니다.
### 온라인 쇼핑몰 재고 관리 : 사용자가 상품을 주문하는 경우
  - 고객이 주문을 완료하면, 상품 재고 수량이 1개 줄어야 합니다.
  - 만약 주문이 취소되면, 재고 수량이 원래대로 복구되어야 합니다.
  - 재고가 0개인데 주문이 들어오면 트랜잭션이 실행되지 않아야 합니다.
</div>
</details>

<details>
<summary><strong>트리거가 뭔가요?</summary>
<div markdown="1">

  - 트리거란, 트랜잭션의 성질 중 일관성을 유지하기 위해 사용되는 명령어로, 데이터베이스에서 특정 이벤트가 발생했을 때 자동으로 실행되는 명령어입니다.
  <br><br>
  <details>
    <summary>❓<꼬리 질문> 트리거의 예시를 하나만 들어보세요.</summary>
      <div markdown="1">
      쇼핑몰 주문 시스템

    ```sql
    CREATE TRIGGER update_stock
    AFTER INSERT ON orders
    FOR EACH ROW
    UPDATE products
    SET stock = stock - NEW.quantity
    WHERE product_id = NEW.product_id;
    ```
  새로운 주문이 들어오면 products 테이블에서 자동으로 재고를 차감하는 트리거를 예시로 들 수 있습니다.
  
  해당 트리거가 존재한다면 주문이 들어왔을 때 자동적으로 재고 변경이 항상 함께 일어나 일관성이 유지됩니다.
  </div>
  </details>
</div>
</details>

<details>
<summary><strong>트랜잭션의 성질 중 영구성(Durabillity)을 보장하기 위해 어떤 방식을 사용하나요?</strong></summary>
<div markdown="1">
  
- WAL(Write Ahead Logging) 방식을 사용합니다.
- WAL이란 데이터베이스를 변경하기 전에 먼저 로그 파일에 변경 내용을 기록하는 방식으로, 시스템 장애가 발생하면 로그 파일을 보고 데이터 복구할 수 있다는 점에서 영구성을 보장할 수 있습니다.
  <br><br>
  <details>
    <summary>❓<꼬리 질문> WAL 방식의 예시를 하나 들어보세요.</summary>
      <div markdown="1">
      계좌 이체를 하는 과정을 예시로 들어보겠습니다.
      
    - A 계좌에서 돈이 빠지기 전에  "A 계좌 -10만 원" 이라는 정보를 로그 파일에 먼저 저장합니다.
    - B 계좌에 돈이 들어가기 전에  "B 계좌 +10만 원" 이라는 정보도 로그 파일에 먼저 저장합니다.
    - 로그 파일에 모든 트랜잭션 변경 내용이 기록되었는지 확인한 후, 실제 데이터베이스를 수정합니다.
    - 만약 시스템이 고장 나더라도 로그 파일을 보고 다시 변경 내용을 재적용하여 데이터 복구함으로써 영구성을 보장할 수 있습니다.
  </div>
  </details>
</div>
</details>

<details>
<summary><strong>독립성이 지켜지지 않아 여러 트랜잭션이 동시에 실행되면 어떤 문제가 발생하나요?</strong></summary>
<div markdown="1">
  
- 여러 트랜잭션이 동시에 실행된다면 여러 읽기 이상 현상이 발생할 수 있으며, 이상 현상의 종류로는  Dirty Read, Non Repeatable Read, Phantom Read 등이 있습니다.
  - Dirty Read(더티 리드)
    - 다른 트랜잭션이 아직 커밋하지 않은 데이터를 읽었는데,해당 트랜잭션이 롤백하면 잘못된 데이터를 읽은 상태가 됨
    - 예) A가 10만 원을 입금했지만 커밋 전, B가 이를 조회 → A가 롤백하면 B가 잘못된 데이터를 봄
  - Non Repeatable Read(비반복 읽기)
    - 같은 데이터를 두 번 조회했는데 값이 다름
    - 이유: 중간에 다른 트랜잭션이 업데이트(UPDATE) 했기 때문
    - 예) A가 고객 정보를 조회 후 수정 버튼을 누름 → B가 데이터를 수정 후 커밋 → A가 다시 조회하면 값이 바뀜
  - Phantom Read(팬텀 리드)
    - 같은 조건으로 두 번 조회했는데 새 데이터가 추가되거나 삭제됨
    - 이유: 중간에 다른 트랜잭션이 새로운 행을 추가(INSERT) 또는 삭제(DELETE) 했기 때문
    - 예) A가 "재고 10개 이상 상품"을 조회 후 처리 중 → B가 새로운 상품을 추가 → A가 다시 조회하면 예상치 못한 데이터 등장
</div>
</details>

<details>
<summary><strong>트랜잭션이 너무 길어질 경우 발생하는 문제점은 무엇이 있을까요?</strong></summary>
<div markdown="1">

  1. 시간이 지날수록 낮은 우선순위의 프로세스 우선순위를 점진적으로 높이는 에이징 기법을 사용하거나 라운드 로빈을 적용해서 모든 프로세스가 일정한 시간 동안 CPU를 사용할 수 있도록 보장하는 방법이 있습니다.
  2. 여러 트랜잭션이 서로가 가진 자원을 기다리면서 무한 대기 상태에 빠지는 Deadlock(교착 상태) 발생 가능성이 증가한다.
  3. 트랜잭션이 길수록 롤백 시 변경된 데이터가 많아지고, 롤백 수행 시간이 오래 걸린다.
</div>
</details>

<details>
<summary><strong>트랜잭션을 실행할 때 성능을 고려해야 하는 경우, 어떤 방식으로 최적화할 수 있을까요?</strong></summary>
<div markdown="1">

  - 적절한 배치 처리(Batch Processing)를 통해 해결합니다.
  - 배치 처리란 여러 개의 트랜잭션을 개별적으로 실행하는 것이 아니라, 한 번에 모아서 실행하여 성능을 최적화하는 기법입니다.
  - 여러 개의 트랜잭션을 개별적으로 실행하면 매번 DB 커넥션을 열고 닫는 과정이 반복되어 오버헤드 발생할 수 있지만 이를 한 번의 트랜잭션 내에서 묶어서 실행하면 디스크 I/O 및 네트워크 요청 횟수를 줄일 수 있기 때문에 성능을 최적화 할 수 있습니다.</div>
</details>
  
---

## 박상윤
<details>
<summary><strong>사용자가 온라인 쇼핑몰에서 상품을 결제하는 과정에서 결제는 정상적으로 이루어졌지만, 주문 내역 저장 과정에서 오류가 발생했습니다. 이로 인해 사용자의 계좌에서는 돈이 빠져나갔지만, 주문 내역이 남지 않아 상품이 배송되지 않는 문제가 발생 했습니다. 트랜잭션의 어떤 특성이 지켜지지 않은 것일까요?</strong></summary>
<div>

  - 원자성, 일관성
</div>
</details>
<details>
<summary><strong>한 사용자가 은행에서 100만 원을 송금했습니다. 송금이 완료된 직후, 은행 서버가 갑자기 다운되었습니다. 이후 서버가 정상적으로 복구되었을 때,  사용자의 계좌에서 100만 원이 차감된 기록은 있었지만, 상대 계좌에는 입금 내역이 존재하지 않는 문제가 발생했습니다. 트랜잭션의 어떤 특성이 지켜지지 않은 것일까요?</strong></summary>
<div>
  
- 원자성
</div>
</details>

<details>
<summary><strong>쇼핑몰 관리자가 새로운 상품을 추가했습니다. 그러나 상품 정보는 정상적으로 데이터베이스에 저장되었지만, 재고 정보 저장 과정에서 오류가 발생했습니다. 이로 인해 소비자가 상품을 조회하면 상품은 존재하지만 재고가 없어 구매할 수 없는 상태가 발생했습니다. 트랜잭션의 어떤 특성이 지켜지지 않은 것일까요?</strong></summary>
<div>
  
- 원자성, 일관성
</div>
</details>
  
<details>
<summary><strong>이벤트로 인해 50% 할인 상품이 1개 남아 있는 상황에서 두 명의 사용자가 동시에 구매 버튼을 눌렀습니다. 재고가 1개임에도 불구하고 두 명의 사용자가 구매완료가 되었습니다. 트랜잭션의 어떤 특성이 지켜지지 않은 것일까요?</strong></summary>
<div>
  
- 독립성
</div>
</details>

<details>
<summary><strong>트랜잭션을 통해 발생할 수 있는 2가지 상황을 트랜잭션 제어 명령어를 통해 설명해주세요.</strong></summary>
<div>
  
- 트랜잭션 성공시 COMMIT되어 DB에 저장, 트랜잭션 진행중 실패시 ROLLBACK되어 DB 이전상태 복구
</div>
</details>

---
  
## 변하영
<details>
<summary><strong>트리거에 대해 설명해주세요</strong></summary>
<div>
  
  - 트리거는 특정 테이블에 대한 이벤트에 반응해 DML문이 수행되었을 때, 데이터베이스에서 자동으로 동작하도록 작성된 프로그램입니다. 사용자가 직접 호출하는 것이 아닌, 데이터베이스에서 자동적으로 호출합니다. 트리거를 통해 ACID 원칙 중 하나인 일관성을 보장합니다. 
</div>
</details>
  
<details>
<summary><strong>트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.</strong></summary>
<div>

  - 트랜잭션은 데이터베이스의 상태를 변화시키기 위해 논리적인 기능을 수행하는 작업 단위로, 작업의 안전성 보장을 위해 필요합니다.
  - 첫번째로, Atomicity(원자성)은 트랜잭션은 모두 실행되거나 전혀 실행되지 않아야 한다는 것이고,
  - Consistency(일관성)는 트랜잭션 작업 처리 전후로 데이터베이스의 상태는 항상 일관성을 유지해야 한다는 것입니다.
  - Isolation(고립성)은 트랜잭션이 실행 중일 대 다른 트랜잭션이 끼어들지 못하도록 보장하는 것입니다.
  - 마지막으로 Durability(지속성)는 트랜잭션이 성공적으로 수행되면 영원히 반영되어야 한다는 것입니다.
</div>
</details>
  
<details>
<summary><strong>트랜잭션이 실패했을 때 데이터의 일관성을 유지하기 위한 방법에는 무엇이 있나요?</strong></summary>
<div>

  - 트랜잭션이 실패했을 때 데이터의 일관성을 유지하기 위해 주로 Rollback을 사용합니다. Rollback은 트랜잭션 실행 중 오류가 발생했을 때, 해당 트랜잭션이 변경한 데이터를 모두 취소하는 연산입니다.  이렇게 처리하는 이유는 트랜잭션 수행 결과가 데이터베이스에 완전히 반영되거나 아예 반영되지 않아야 하기 때문입니다. 
</div>
</details>
  
<details>
<summary><strong>ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?</strong></summary>
<div>

  - DBMS는 Write-Ahead Logging (WAL) 을 사용하여 변경 사항을 먼저 로그에 기록한 후, 데이터를 반영합니다. 장애 발생 시 해당 로그를 통해 복구 가능합니다. 
</div>
</details>
  
<details>
<summary><strong>읽기에는 트랜잭션을 걸지 않아도 될까요?</strong></summary>
<div>
  
  - 일반적인 단일 읽기 작업의 경우 트랜잭션이 필요없지만, 상황에 따라 읽기 작업에도 트랜잭션이 필요할 수 있습니다. 복수의 읽기 작업이 일관된 데이터를 읽어야 할 때, 트랜잭션을 사용하여 중간에 다른 트랜잭션에 의해 데이터가 변경되는 것을 방지할 수 있습니다. 
</div>
</details>
  
---
  
## 신예지
<details>
<summary><strong>트랜잭션의 성질 중 독립성(Isolation)이 지켜지지 않을 경우 발생하는 문제를 예시를 들어 간략하게 설명해주세요(Dirty Read, Non-Repeatable Read, Phantom Read x → 다음 주제에서 다룸)</strong></summary>
<div>

- 은행을 예로 들어보겠습니다. 현재 A에게는 0원이 있고, B와 C에게는 10000원이 있습니다. 만약 A에게 B, C가 각각 10000원을 동시에 송금했을 때 독립성이 지켜지지 않으면, A의 잔고는 20000원이 아니라 10000원이 되고, B와 C는 각각 0원인 상태가 발생합니다.
</div>
</details>

<details>
<summary><strong>만약 트랜잭션의 마지막 연산까지 실행 후 트랜잭션에 문제가 생겨 중단되었습니다. 이때 트랜잭션이 실행할 연산은 무엇인가요?</strong></summary>
<div>

- 트랜잭션의 마지막 연산까지 실행된 상태는 부분 완료 상태로, COMMIT 연산이 실행되기 직전인 상태입니다. 이때 트랜잭션에 문제가 생겨 중단이 되면 실패 상태가 되고, ROLLBACK 연산을 통해 트랜잭션이 철회됩니다.
</div>
</details>
 
<details>
  <summary><strong>트랜잭션의 원자성에 대해 설명하고, 원자성을 보장하기 위해 어떤 로그를 사용하나요?</strong></summary>
  <div>

  - 원자성은 all or nothing 처럼 모두 정상적으로 실행되거나 아예 실행되지 않아야 한다는 성질입니다. 만약 트랜잭션 실행 도중 오류가 발생한다면 UNDO 로그 정보를 이용해 지금까지 실행한 연산 처리를 모두 취소(ROLLBACK)합니다.
  </div>
</details>

<details>
  <summary><strong>WAL(Write-Ahead Logging)에 대해 설명해주세요</strong></summary>
  <div>

  - WAL은 DBMS의 무결성을 보장하기 위한 로그 기반 트랜잭션 처리 방법입니다.
  - 즉, 트랜잭션이 실행되면서 변경된 데이터를 바로 디스크에 저장하는 것이 아니라, 로그(redo/undo 로그)를 먼저 저장한 후 데이터베이스를 갱신하는 방식입니다.
  <details>
  <summary>꼬리질문) 왜 WAL 방식을 사용할까요?</summary>
  <div>
      
  - 데이터를 바로 하드디스크에 저장하는 대신, 로그에 기록하고 한 번에 하드디스크에 저장하면 I/O 비용(시간)을 줄일 수 있습니다. 
  </div>
  </details>
  </div>
</details>

<details>
  <summary><strong>UNDO 로그와 REDO 로그는 각각 트랜잭션의 어떤 성질을 보장하기 위해 사용하는지와 어떤 상황에서 사용하는지 설명해주세요</strong></summary>
  <div>

  - UNDO 로그는 트랜잭션의 원자성을 보장하기 위해 사용하고, REDO 로그는 트랜잭션의 지속성을 보장하기 위해 사용합니다. UNDO 로그는 트랜잭션 실행 중 오류가 발생하여 이전 상태로 돌아가기 위해 필요한 정보이고, REDO 로그는 COMMIT까지 완료한 트랜잭션에 대해 오류가 발생했을 때 데이터를 복구하기 위해 필요한 정보입니다.
  </div>
</details>

---

## 이소원

<details>
  <summary><strong>트랜잭션이 뭔가요?</strong></summary>
  <div>

  - 트랜잭션(Transaction)은 데이터베이스에서 하나의 논리적인 작업 단위로 ACID (원자성, 일관성, 격리성, 지속성)을 보장해야 합니다.
  - 모든 작업이 성공해야만 반영되며, 하나라도 실패하면 전체가 롤백(ROLLBACK)됩니다.
  - 은행 계좌 이체, 주문 처리 시스템, 결제 프로세스 등에서 데이터 정합성을 보장하기 위해 트랜잭션이 필수적으로 사용됩니다.
  </div>
</details>

<details>
  <summary><strong>ACID 속성이 뭔가요?</strong></summary>
  <div>
    ACID는 트랜잭션의 4가지 필수 속성을 의미합니다.

1. 원자성 (Automicity) : all or notihing
    
    - 모든 작업이 **완전히 실행되거나(Rollback 없이)** 실행되지 않아야 합니다.
    - (결제 중 오류 발생 시 돈이 빠져나가지 않도록 ROLLBACK)
    
2. 일관성 (Consistency)
    
    - 트랜잭션 실행 전후로 데이터베이스가 **일관성을 유지**해야 합니다.
    - (재고가 부족한 경우 주문이 성사되지 않도록 검증)
    
3. 격리성/고립성 (Isolation)
    
    - 동시에 실행되는 트랜잭션에 대해 서로 영향을 주지 말아야 합니다.
    - (동시 주문 시 재고 데이터가 충돌하지 않도록 트랜잭션 격리 수준 적용)
    
4. 지속성 (Durability)
    
    - 트랜잭션이 완료되면 데이터가 영구적으로 저장되어야 합니다.
    - (결제가 완료되면 DB에 영구적으로 반영)
  </div>
</details>

<details>
  <summary><strong>트랜잭션은 왜 쓰나요?</strong></summary>
  <div>

  - 작업의 안전성을 보장하기 위해 사용합니다.
  - 트랜잭션은 데이터베이스에서 하나의 거래를 안전하게 처리하도록 보장해주는 방법입니다.
  </div>
</details>

<details>
  <summary><strong>여러 트랜잭션이 동시에 실행될 때 발생할 수 있는 문제는 무엇인가요?</strong></summary>
  <div>

1. 더티 리드 (Dirty Read)
  
  - 다른 트랜잭션이 커밋하지 않는 데이터를 읽는 것
  - 해결 방법 : Read commit 이상 사용
    
2. Non-Repeatable Read
      
  - 같은 데이터를 조회할 때 **결과가 다름**
  - 해결 방법 : Repeatable Read 이상 사용
    
3. 팬텀 리드 (Phantom Read)
  
  - 트랜잭션 시행 중 새로운 행이 삽입됨
  - 해결 방법 : Serializable 사용
  </div>
</details>

<details>
  <summary><strong>트랜잭션 성능 최적화를 위해 어떤 전략을 사용할 수 있을까요?</strong></summary>
  <div>

실무에서는 트랜잭션이 **데이터 정합성을 유지하면서도 성능을 최적화**해야 합니다.

1. **트랜잭션 범위를 최소화** → 오래 걸리는 작업을 트랜잭션 밖에서 처리
2. **적절한 격리 수준 설정** → `Read Committed`를 기본으로 사용
3. **인덱스를 활용하여 조회 성능 향상**
4. **배치 처리 (Batch Processing) 적용** → 다량의 데이터를 한 번에 처리
5. **비동기 처리 활용** → 트랜잭션이 필요 없는 작업을 분리
  </div>
</details>

<details>
  <summary><strong>트랜잭션을 최소한의 코드로 사용해야하는 이유가 뭘까요? (트랜잭션의 범위를 최소화해야하는 이유)</strong></summary>
  <div>

1. 트랜잭션이 실행되는 동안에는 락이 걸려 다른 트랜잭션이 접근하지 못합니다. 따라서 트랜잭션이 길어지면 다른 요청들의 대기해야 해서 성능이 낮아지는 문제가 발생합니다.
2. 트랜잭션이 유지되는 동안에는 데이터베이스는 여러 가지 작업을 계속 유지해야 하기 때문에 메모리 사용량이 증가하여 서버 부하가 커지고 처리 속도가 느려지는 문제가 발생할 수 있습니다.
3. 트랜잭션이 길어질 수록 여러 트랜잭션이 서로 락을 기다리는 상황(Dead Lock)이 발생할 확률이 높아집니다.
  </div>
</details>

<details>
  <summary><strong>쇼핑 사이트에서 사용자가 구매 버튼을 누른 직후, 서버에서 결재처리가 되어 돈은 빠져 나갔지만 상품 주문처리에서 오류가 발생했을 때, 원자성이 지켜지지 않는다면 어떤 문제가 발생할까요?
(현재 서버에서는 결제와 상품 주문이 하나의 트랜잭션 단위로 묶여 있습니다.)</strong></summary>
  <div>

  - 원자성이 지켜지지 않으면, 결제는 정상적으로 이루어졌지만 주문 처리는 오류로 인해 진행되지 않는 문제가 발생할 수 있습니다.
  </div>
</details>

<details>
  <summary><strong>쇼핑몰 관리자가 새로운 상품을 추가하기 위해 상품 추가 버튼을 누른 직후, 서버에 상품 정보를 저장했지만 상품의 재고 상태 갱신시 오류가 발생했습니다. 일관성이 지켜지지 않을 경우 어떻게 될까요?</strong></summary>
  <div>

  - 상품 정보는 DB에 저장이 되었지만, 동일 상품에 대한 재고 정보가 없으므로, 소비자가 해당 상품 조회시 재고가 존재하지 않기때문에 구매를 할 수 없게 됩니다.
  </div>
</details>

<details>
  <summary><strong>DBMS에서는 영구성을 보장하기 위해 뭘 사용할 수 있을까요?</strong></summary>
  <div>

  - 미리 쓰기 로깅(WAL → Write Ahead Logging)을 사용합니다.
    - 미리 쓰기 로깅 : 데이터를 변경하기 전에 먼저 로그에 기록하는 기법.

      데이터베이스에 변경 사항을 적용하기 전에 로그에 먼저 기록해서 장애가 발생해도 복구할 수 있도록 보장하는 방법
  </div>
</details>
