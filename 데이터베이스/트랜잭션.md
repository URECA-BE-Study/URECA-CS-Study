
# 트랜잭션(Transaction)이란?
데이터베이스의 논리적 작업 단위 
데이터 베이스의 상태를 바꾸기 위해 그리고 하나의 작업을 수행하기 위해 실행되는 일련의 연산들을 의미한다.
트랜잭션이 성공적으로 수행되면 데이터베이스는 영구적으로 변경되며 실패하면 변경 사항이 취소된다.

<br><br>
  
## 작업 단위란?
DB에서 작업 단위(Unit of Work)는 하나의 논리적인 작업을 수행하는 최소 단위며, 하나의 쿼리 묶음이라고 생각하면 된다.
쉽게 말해, "이거 하나는 다 처리되어야 해!"라고 묶을 수 있는 작업 덩어리라고 볼 수 있다.
즉, 많은 SQL 명령문들을 사람이 정하는 기준에 따라 정하는 것이다.

- 예제 1 : 은행 계좌 이체
  "A 계좌에서 5만 원 빼고, B 계좌에 5만 원 넣어줘"

  이 작업은 반드시 함께 실행되어야 한다. (한쪽만 실행되면 돈이 사라지거나, 뻥튀기될 수도 있다.)
  따라서 이 두 가지 작업을 하나의 작업 단위로 묶어야 한다.

  따라서 작업 단위는
    A 계좌에서 50,000원 출금
    B 계좌에 50,000원 입금
    이 두 개가 하나의 묶음이다.

  만약 중간에 오류가 나서 A에서 돈만 빠져나가고 B에는 입금되지 않았다면?
  → 전체 작업을 취소(ROLLBACK)하고 처음 상태로 되돌려야 한다

- 예제 2: 쇼핑몰에서 주문하기
  "상품 하나 주문했을 때 해야 할 일"

  1. 상품 재고 줄이기 (재고에서 상품 하나 빼기)
  2. 주문 내역 저장 (내가 어떤 상품을 주문했는지 기록)
  3. 결제 정보 저장 (내가 결제한 내역 저장)
  4. 이 세 가지가 전부 다 성공해야 정상적으로 주문이 완료된다.
  하나라도 실패하면? → 전부 취소(ROLLBACK)하고 처음 상태로 되돌려야 한다.

<br><br>

## 트랜잭션과의 관계
- 작업 단위는 트랜잭션이 보장해 주는 논리적인 작업 덩어리이다.
- 트랜잭션은 이 작업 단위들을 "묶어서 한 번에 처리" 하거나 "오류 나면 전부 취소" 하도록 해준다.

👉 트랜잭션을 쓰는 이유는?

: 작업 단위가 온전하게 실행되도록 보장하기 위해서

<br><br>
<br><br>


# 트랜잭션의 특성 (ACID)
트랜잭션이 올바르게 수행되려면 ACID 원칙을 준수해야 한다.

<br><br>

1. **Atomicity (원자성)**
  - All or Nothing
  - 트랜잭션의 연산들이 모두 수행되거나, 하나도 수행되지 않아야 한다.
  - 예: A → B로 돈을 이체할 때, A의 돈이 빠져나갔지만 B의 계좌에는 입금되지 않는 경우가 없어야 한다.
  - 원자성은 수행하고 있는 트랜잭션에 의해 변경된 내역을 유지하면서, 이전어 커밋된 상태를 임시 영역에 따로 저장함으로써 보장함
    - 현재 수행하고 있는 트랜잭션에서 오류가 발생하면 현재 내역을 날리고 임시 영역에 저장해뒀던 상태로 rollback함
      - 롤백 세그먼트(rollback segment): 이전 데이터들이 임시로 저장되는 영역으로, 수정되기 전의 파일이나 블록 ID 같은 블럭 정보 및 데이터를 저장함
    - 일반적으로 Rollback을 명시하면 INSERT, DELETE, UPDATE 등의 작업 전체가 취소되는데, 확실하게 오류가 발생하지 않은 부분도 다시 처음부터 작업을 수행해야 함(문제)
      - 이러한 부분을 해결하기 위해 중간 저장 지점인 save point를 지정하여 해결가능
      - save point를 사용하면 전체가 아닌 특정 부분에서 트랜잭션을 취소시킬 수 있음

![원자성 commit savepoint 동작 방식](https://blog.kakaocdn.net/dn/D641b/btsMcSnyxj1/1Ij1APca4xK4MlLZXqthFk/img.png)
 
```sql
commit; --마지막 commit

update dept
  set dname = 'QC2'
  where deptno=70;
savepoint SP1; --SP1 세이브포인트

delete from dept
  where deptno = 70;
savepoint SP2; --SP2 세이브포인트

insert into dept values (50, '부서명', '지역명');

rollback; -- savepoint가 없으면 마지막 commit 시점으로 돌아가서 update/delete/insert 모두 롤백됨
rollback to savepoint SP1; -- SP1 시점으로 이동하여, SP1 이후로 수행했던 작업들이 모두 롤백됨
```

  - save point: 트랜잭션 내부에서 사용자가 지정할 수 있는 세부 작업 단위
  - 특정 지점에 SAVEPOINT SP1를 설정 한 후 ROLLBACK TO SP1를 통해 해당 지점으로 롤백할 수 있음

<br><br>

2. **Consistency (일관성)**

  - 트랜잭션이 실행되기 전과 후에 데이터베이스의 무결성이 유지되어야 한다.
  - 트랜잭션은 완료 후에도 데이터베이스가 일관된 상태로 유지되어야 한다.
  - 예: 은행 계좌의 전체 잔액 합계가 변하지 않아야 한다.
  - 트랜잭션에서는 트리거를 통해서 일관성을 보장
    - 트리거는 특정 테이블에 쿼리 작업과 같은 이벤트가 발생했을 때, 사용자가 직접 호출하는 것이 아닌 데이터베이스에서 자동으로 호출하여 동작하도록 하는 것
    - ex) 데이터베이스에서는 정보의 수정이 일어났을 경우에 다른 테이블도 함께 정보가 수정될 수 있도록 명시적으로 자동 업데이트하는 명령을 구성함

<br><br>

3. **Isolation (고립성, 격리성)**

  - 여러 트랜잭션이 동시에 실행되더라도, 서로의 작업에 영향을 주지 않아야 한다.
  - 하나의 트랜잭션이 실행하는 도중에 변경한 데이터는 해당 트랜잭션이 완료될 때까지 다른 트랜잭션이 참조하지 못한다.
  - 예: 두 사용자가 동시에 같은 계좌에서 출금하려 할 때, 하나의 트랜잭션이 완료될 때까지 다른 트랜잭션이 영향을 받지 않도록 해야 합니다.

<br><br>

4. **Durability (지속성, 영구성)**

  - 트랜잭션이 완료된 후에는 시스템 장애가 발생해도 변경 사항이 유지되어야 한다.
  - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다.
  - 예 : 전산 시스템이 꺼지더라도 송금 기록이 유지되어야 합니다.
  
  - DBMS에서는 영구성을 보장하기 위해 미리 쓰기 로깅(WAL - Write Ahead Logging)을 사용한다.
    - WAL에서는 실제 데이터베이스를 수정하기 전에 DBMS가 변경 사항을 디스크의 로그 파일에 기록한다.
      - 로그(Log)는 로그 레코드의 연속이며 데이터베이스의 모든 갱신 작업을 저장한다.
    - 변경 사항이 로그에 안전하게 기록되면 DBMS가 데이터베이스를 업데이트 한다.
    - 이후, 시스템 충돌과 같은 장애가 발생하면 DBMS는 기록된 트랜잭션을 재생하고 데이터를 일관된 상태로 복원하여 데이터베이스를 복구할 수 있다.
    - 영속성만 보장해 주는 것이 아니라 log는 여러가지를 보장해주는데 그 중 영구성도 보장한다는 의미로 받아들이자

<br><br>
<br><br>

# 트랜잭션 상태
트랜잭션은 아래와 같은 상태를 거친다.
1. Active (활성) : 트랜잭션이 시작되어 처리 중인 상태 (실행중)
2. Partially Committed (부분 완료) : 트랜잭션의 마지막 연산까지 처리가 완료되었지만 DB에 트랜잭션 수행 결과가 반영되지 않은 상태 (Commit 연산이 실행되기 직전 상태) 
3. Committed (완료) : 트랜잭션이 정상적으로 완료되어 변경 사항이 데이터베이스에 반영된 상태
4. Failed (실패) : 트랜잭션 처리 중 오류로 인해 트랜잭션이 중단된 상태
5. Aborted (철회) : 실패한 트랜잭션이 롤백(rollback)되어 원래 상태로 복구된 상태

<br><br>

### 트랜잭션 수행 단계 도식화
 ![트랜잭션 수행 단계 도식화](https://blog.kakaocdn.net/dn/bjrefJ/btsMcH7mLkX/gYIwzYfCgyN2zJ4L4Vjovk/img.png)
 
<br><br>
<br><br>

# 트랜잭션 명령어 (SQL)
## TCL(Transaction Control Language)
트랜잭션을 다룰 때 일반적으로 사용되는 SQL 명령어

상태를 변화시킨다. → SQL 질의어를 통해 DB에 접근한다.

1. 트랜잭션 시작
```
START TRANSACTION;
```
또는
```
BEGIN;
```

<br><br>

2. 트랜잭션 저장 (완료)
```
COMMIT;
```
- 모든 변경 사항을 데이터베이스에 반영
- 트랜잭션이 정상적으로 종료되어 DB에 변경 사항을 반영하는 명령어
- 한 개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났고 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산

<br><br>

3. 트랜잭션 취소 (롤백)
```
ROLLBACK;
```
- 트랜잭션이 비정상적으로 종료되어 트랜잭션이 수행한 변경 사항을 취소하고 DB를 이전 상태로 되돌리는 명령어
- 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산
- Rollback 시에는 해당 트랜잭션을 재시작하거나 폐기함

<br><br>

4. 특정 지점까지 롤백 (세이브포인트)
```
SAVEPOINT 저장점이름;
ROLLBACK TO 저장점이름;
```
- 트랜잭션에서 특정 지점을 지정하는 명령어로, ROLLBACK과 함께 사용하면 해당 지점까지 되돌릴 수 있다.

<br><br>
<br><br>

# 트랜잭션을 다룰 때 발생할 수 있는 문제점들
1. 더티 리드(Dirty Read)
- 다른 트랜잭션이 커밋되지 않은 변경 사항을 읽는 현상
- 트랜잭션 A가 변경한 데이터를 트랜잭션 B가 커밋 전에 읽으면 데이터 정합성이 깨질 수 있다.
- 예: A가 돈을 송금했지만 트랜잭션이 롤백되었을 때, B가 A의 계좌에서 돈이 빠져나간 것처럼 보이는 경우

2. Non-Repeatable Read (비반복 가능 읽기)
- 같은 데이터를 두 번 읽을 때 값이 변경되는 현상
- 두 개의 트랜잭션이 동일한 데이터를 수정할 경우 데이터 충돌이 발생
- 예: 한 트랜잭션에서 특정 고객의 잔액을 조회했는데, 다른 트랜잭션이 잔액을 변경하면 첫 번째 조회 결과와 다르게 나옴
- 해결 방법: 트랜잭션 격리 수준 조정 (Repeatable Read 이상)

3. Phantom Read (팬텀 리드)
- 한 트랜잭션이 특정 조건을 만족하는 행을 조회했는데, 이후 다른 트랜잭션이 행을 추가하거나 삭제하여 결과가 달라지는 현상
- 예: SELECT COUNT(*) FROM users WHERE age > 30; 이후 다른 트랜잭션이 31세 사용자를 추가하면 결과가 달라짐


<br><br>
<br><br>

# 트랜잭션 최적화
트랜잭션의 최적화를 위해 다음과 같이 수행할 수 있다.
1. **트랜잭션 범위를 최소화** → 오래 걸리는 작업을 트랜잭션 밖에서 처리
2. **적절한 격리 수준 설정** → `Read Committed`를 기본으로 사용
3. **인덱스를 활용하여 조회 성능 향상**
4. **배치 처리 (Batch Processing) 적용** → 다량의 데이터를 한 번에 처리
5. **비동기 처리 활용** → 트랜잭션이 필요 없는 작업을 분리

<br><br>

## 트랜잭션을 최소화해야 하는 이유는?
1. 트랜잭션이 실행되는 동안에는 락이 걸려 다른 트랜잭션이 접근하지 못한다. 따라서 트랜잭션이 길어지면 다른 요청들의 대기해야 해서 성능이 낮아지는 문제가 발생한다.
2. 트랜잭션이 유지되는 동안에는 데이터베이스는 여러 가지 작업을 계속 유지해야 하기 때문에 메모리 사용량이 증가하여 서버 부하가 커지고 처리 속도가 느려지는 문제가 발생할 수 있다.
3. 트랜잭션이 길어질 수록 여러 트랜잭션이 서로 락을 기다리는 상황(Dead Lock)이 발생할 확률이 높아진다.
4. DB connection 작업이 너무 빈번해져서 오버헤드가 발생할 수 있다.
5. 트랜잭션이 DB connection을 오히려 오래 붙잡고 있어서 오버헤드 발생할 수 있다.
<br><br>
이러한 문제를 해결하기 위해
1. 배치(batch) 처리를 하여 여러 개의 관련 작업을 하나의 트랜잭션을 묶어서 실행한다.
2. 트랜잭션의 범위를 최소화하여 필요 이상으로 길어지지 않도록 조정한다.

<br><br>
---
<br><br>

# 트리거(Trigger)란?
트리거(Trigger)는 특정 이벤트(INSERT, UPDATE, DELETE)가 발생할 때 자동으로 실행되는 데이터베이스 객체(규칙)이다.
- 수동 실행이 아니라, **DBMS가 자동으로 실행**한다.  
- 데이터 무결성 유지, 로깅, 자동 업데이트 등에 사용된다.

<br><br>

## 트리거와 트랜잭션의 관계
트리거는 트랜잭션의 일부로 동작하며 트랜잭션이 시작될 때 함께 실행된다.
만약 트랜잭션이 ROLLBACK되면, 트리거에서 수행한 작업도 취소된다.

### 트리거의 역할
1. 데이터 무결성 유지 → 예를 들어, 직원이 퇴사하면 관련 테이블의 데이터를 자동 정리  
2. 로그 기록 → 계좌 이체 시, 자동으로 로그 테이블에 기록 남김  
3. 자동 계산 및 업데이트 → 상품 주문 시, 재고를 자동으로 감소  

<br><br>

## 트랜잭션에서 트리거 사용 예제
### 예제 1: 계좌 이체 로그 자동 기록
- 사용자가 송금(UPDATE)을 하면 자동으로 트리거가 실행되어 로그를 기록
```sql
CREATE TRIGGER transfer_log_trigger
AFTER UPDATE ON accounts
FOR EACH ROW
WHEN (OLD.balance > NEW.balance) -- 출금이 발생한 경우
BEGIN
    INSERT INTO transfer_logs(account_id, amount, transfer_date)
    VALUES (OLD.account_id, OLD.balance - NEW.balance, CURRENT_TIMESTAMP);
END;
```

- 계좌에서 출금(UPDATE)이 발생하면 트리거가 실행됨  
- 트랜잭션 내부에서 송금한 금액을 로그 테이블에 자동 저장


### 예제 2: 주문 시 재고 자동 감소
- 사용자가 주문을 하면(INSERT) 트리거가 실행되어 재고 감소
```sql
CREATE TRIGGER update_stock_trigger
AFTER INSERT ON orders
FOR EACH ROW
BEGIN
    UPDATE inventory
    SET stock = stock - NEW.quantity
    WHERE product_id = NEW.product_id;
END;
```

- 새로운 주문(INSERT)이 발생하면 트리거가 실행
- 주문된 상품의 재고를 자동으로 감소

<br><br>

## 트리거와 ROLLBACK의 관계
1. 트리거 내부에서 예외 발생 시 트랜잭션이 ROLLBACK된다.  
2. 트랜잭션이 ROLLBACK되면, 트리거에서 수행한 작업도 자동 취소된다.

### 예제: 재고 부족하면 주문 취소 (ROLLBACK)
```sql
CREATE TRIGGER check_stock_before_order
BEFORE INSERT ON orders
FOR EACH ROW
BEGIN
    IF (SELECT stock FROM inventory WHERE product_id = NEW.product_id) < NEW.quantity THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '재고 부족';
    END IF;
END;
```

- 주문(INSERT) 전에 실행되는 트리거  
- 재고가 부족하면 오류 발생 → 트랜잭션이 ROLLBACK

<br><br>

## 정리
- **트리거는 트랜잭션과 함께 동작**하며, 특정 이벤트 발생 시 자동 실행
- **트리거에서 예외가 발생하면 트랜잭션 전체가 ROLLBACK됨**  
- **트랜잭션이 ROLLBACK되면 트리거의 작업도 취소됨**  
- 실무에서는 **데이터 무결성 유지, 로깅, 자동 업데이트** 등에 활용
