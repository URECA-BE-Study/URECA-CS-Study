## 이소원
<details>
  <summary>2-way handshake 의 문제점과 해결 방법에 대해 설명하세요.</summary>
문제점은 패킷 손실이 연결 확인이 불가능하다는 것입니다. 클라이언트가 syn을 보내고 서버가 응답했는지에 대한 확인 방법이 없기 때문입니다.
이를 해결하기 위해 서버가 syn-ack를 보내고, 클라이언트가 이에 대해 연결 확인 메세지 ack로 응답하여 연결을 확인할 수 있는 방법이 있습니다.
(3-way handshake)
</details>
<br>
<details>
  <summary>왜 신뢰성 있는 연결 종료가 필요한가요? (4-way handshake의 필요성)</summary>
데이터 손실 방지

- 송신자가 FIN을 보낸 후, 수신자가 아직 처리하지 못한 데이터가 있을 수도 있습니다.
- FIN → ACK을 주고받으며 모든 데이터가 정상적으로 도착했음을 확인하고 종료해야 합니다.

2. Half-Close 지원

- 한쪽에서 FIN을 보내더라도, 상대방이 데이터를 더 보낼 수도 있습니다.
- 이를 위해 각 방향별로 독립적으로 FIN과 ACK을 주고받으며 종료해야 합니다.

3. Half-Open 연결 방지

- 일방적으로 종료하면 상대방은 연결이 끊겼는지 모름. FIN과 ACK을 주고받아 서로 종료를 확실히 인지하도록 합니다.
</details>
<br>
<details>
  <summary>Half-Close를 써야하는 이유를 설명해주세요</summary>
TCP 연결에서는 두 개의 데이터 스트림(송신/수신)이 존재하기 때문에, 일방적으로 연결을 종료하면 데이터 유실이나 오류가 발생할 수 있습니다. 이를 방지하기 위해 Half-Close를 사용해야 합니다.

안정적인 연결 종료, 데이터 무결성 보장, 시스템 리소스 최적화
</details>
<br>
<details>
  <summary>TCP 3-way handshake에서 맨 처음 클라이언트가 SYN을 보낼 때 데이터의 SEQ# 를 난수로 하여 전송하는 이유는?</summary>
connection을 맺을 때 사용하는 포트는 유한 범위 내에서 사용하고, 시간이 지남에 따라 재사용됩니다.  

이 때문에 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 재사용 하는 가능성이 존재합니다.  

서버 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데, 난수가 아닌 순차적 number가 전송되면 이 전의 connection으로 오는 패킷으로 인식할 수 있는 문제가 발생할 수 있습니다.  

또한 순차적으로 사용하여 Sequence Number가 노출되면 공격자가 위조 패킷을 보낼 수 있다. (보안 문제)  

이러한 문제들이 발생할 가능성을 줄이기 위해 랜덤 값으로 설정하여 전송합니다.
</details>
<br>
<details>
  <summary>TIME_WAIT 상태란 무엇이며, 왜 필요할까요?</summary>
- TIME_WAIT: 4-Way Handshake 후, 마지막 ACK가 정상적으로 전달되었는지 확인하기 위해 일정 시간 동안 소켓을 유지하는 상태를 의미합니다.

-TIME_WAIT 이 필요한 이유는  
- 마지막 ACK가 유실될 경우, 상대방이 FIN을 재전송할 수 있도록 합니다.  
- 패킷이 지연되어 잘못된 세션이 재사용되는 문제 방지합니다.  
</details>
<br>
<details>
  <summary>TIME_WAIT 상태가 너무 많으면 서버 성능에 어떤 문제가 생기나요?</summary>
많은 TIME_WAIT 상태의 소켓이 열려 있으면 리소스(메모리, 포트 사용)가 낭비됩니다.
서버에서 동시에 처리할 수 있는 연결 수 제한 문제가 발생할 수 있습니다.

해결 방법

- 포트 재사용 (SO_REUSEADDR, SO_REUSEPORT 옵션 사용)
- TCP 설정 조정 (TIME_WAIT 시간 줄이기)
- Keep-Alive 기능 활성화
</details>
<br>
<details>
  <summary>TCP 연결 설정(3-Way Handshake) 중 SYN Flood 공격이란 무엇이며, 어떻게 방어할 수 있을까요?</summary>  
 
- SYN Flood 공격이란   
 클라이언트가 SYN 패킷만 보내고 ACK를 보내지 않아 서버의 연결 대기 큐가 가득 차게 만드는 공격을 의미합니다.

- 방어 방법
    - SYN Cookies: SYN+ACK을 보내기 전에 ISN에 클라이언트 정보를 포함하여 저장 공간을 줄일 수 있습니다.
    - 방화벽 설정: 특정 IP에서 너무 많은 SYN 요청이 오면 차단하도록 할 수 있습니다.
    - Rate Limiting: 초당 SYN 요청 수를 제한할 수 있습니다.
</details>
<br>
<details>
  <summary>클라이언트와 서버 간의 연결이 비정상적으로 종료되었을 때 발생할 수 있는 문제는 무엇인가요?</summary>

- 데이터 유실: FIN 없이 연결이 끊기면, 일부 데이터가 손실될 수 있습니다.  
- 소켓 리소스 낭비: 서버는 CLOSE_WAIT 상태에서 계속 대기하여 불필요한 리소스를 사용합니다.
- 해결 방법: TCP Keep-Alive 활성화, 일정 시간 후 강제 종료(TIME_WAIT 조정)
</details>
<br>
<details>
  <summary>만약 3-Way Handshake 과정에서 마지막 ACK가 유실되면 어떻게 되나요?</summary>

- 서버는 SYN_RECEIVED 상태에서 일정 시간 동안 ACK 재시도
- 일정 시간 후에도 응답이 없으면 연결을 닫음
- 이런 문제를 줄이기 위해 TCP Retransmission(재전송) 메커니즘 사용
</details>
<br>
<details>
  <summary>TCP 대신 UDP를 사용하는 경우, Handshake 과정이 필요 없는 이유는?</summary>

- UDP는 비연결형 프로토콜이므로 Handshake 과정 없이 바로 데이터 전송 가능
- 하지만 패킷 유실, 순서 보장 없음 등의 문제 발생 가능
- 따라서 실무에서는 UDP 위에 신뢰성 있는 프로토콜(예: QUIC, RTP) 추가하여 해결
</details>

## 신예지

<details>
  <summary>2-way handshake가 신뢰성 있는 연결을 보장하지 못하는 이유에 대해 설명해 주세요</summary>
2-way handshake는 클라이언트가 연결 요청을 보내고, 서버가 이를 수락한 후 연결이 성립되는 방식입니다. 이 방식은 클라이언트가 보낸 요청이 서버에 도달했는지 확인할 수 없고 서버가 응답을 보내도 그 응답이 실제로 클라이언트에게 도달했는지 확인할 수 없습니다. 이는 네트워크에서 패킷 손실이나 지연, 공격에 취약하게 만들기 때문에 신뢰성을 보장할 수 없습니다. 3-way handshake는 이러한 문제를 해결하여 연결을 더 안정적이고 신뢰성 있게 만듭니다.
</details>
<br>
<details>
  <summary>SYN Flood 공격이란 무엇이며, 이를 방어하기 위한 방법은 무엇이 있나요?</summary>
SYN Flood 공격은 공격자가 서버에 수많은 SYN 패킷을 보내 서버의 자원을 고갈시키고, 정상적인 연결을 방해하는 서비스 거부(DoS) 공격입니다. 이 공격에서 서버는 클라이언트의 SYN 요청을 받으면 SYN-ACK 패킷을 보내고 클라이언트의 ACK 패킷을 기다립니다. 하지만 공격자는 ACK를 보내지 않아서 서버는 계속 기다리게 되고 자원을 소모하게 됩니다.

이를 방어하는 방법에는 SYN cookies 사용, SYN cache를 통한 비동기 처리, 방화벽 및 침입 탐지 시스템(IDS) 사용 등이 있습니다. 또한, tcp_keepalive 설정을 통해 비정상적인 연결을 조기에 종료할 수 있습니다.
</details>
<br>
<details>
  <summary>4-way handshake에서 TIME_WAIT 상태의 필요한 이유와 그 역할에 대해 설명해 주세요</summary>

1. **잔여 패킷 처리:** 종료된 연결에서 아직 네트워크를 통해 전송되지 않은 패킷들이 남아 있을 수 있습니다. TIME_WAIT 상태에서 일정 시간이 지나면 이 패킷들이 사라지고, 재전송되지 않게 됩니다.
2. **새로운 연결과의 충돌 방지:** 동일한 IP와 포트 조합에서 새로운 연결이 바로 시작되면 이전 연결의 패킷들이 새로운 연결에 혼동을 일으킬 수 있습니다. TIME_WAIT 상태에서 기다림으로써 이러한 충돌을 방지합니다.
</details>
<br>
<details>
  <summary>TCP에서 RST 플래그의 역할에 대해 설명해 주세요</summary>
TCP에서 RST 플래그는 연결을 강제로 종료하는 역할을 합니다. 이 플래그는 두 가지 주요 경우에 사용됩니다:

1. **비정상적인 연결 종료:** 클라이언트나 서버가 정상적인 연결을 종료하지 않고 비정상적으로 연결을 끊으려고 할 때 사용됩니다.
2. **잘못된 연결 시도:** 연결되지 않은 포트나 잘못된 연결 요청이 있을 때, RST 플래그를 보내어 해당 연결을 거부하고 상대방에게 오류를 알려줍니다. 이를 통해 불필요한 연결 시도를 방지하고 네트워크 자원을 낭비하지 않게 됩니다.
</details>
<br>
<details>
  <summary>Abrupt connection release와 Graceful connection release의 차이에 대해 설명해주세요</summary>
Abrupt connection release는 연결을 예고 없이 갑자기 종료하는 방식입니다. 

예를 들어, 시스템 오류나 네트워크 장애가 발생하여 연결이 갑자기 끊어질 때 발생할 수 있습니다. 이 방식은 상대방에게 연결 종료 사실을 알리지 않기 때문에 데이터 손실이나 상태 불일치가 발생할 수 있습니다. 연결이 갑자기 끊어지기 때문에 상대방은 더 이상 데이터를 받을 수 없거나, 세션 상태를 정확하게 파악하지 못할 수 있습니다.

Graceful connection release는 TCP의 정상적인 종료 절차인 4-way handshake를 따르는 방식입니다.

이 과정에서 클라이언트와 서버는 각각 FIN 패킷을 주고받으며 연결 종료를 합의합니다. 이 방식은 연결 종료가 안정적이고 양측 모두 데이터가 완전히 전달된 후에 연결이 종료되므로 데이터 손실을 방지할 수 있습니다. 또한 종료 과정이 명확하게 이루어지기 때문에 양쪽 모두 종료 시점을 알 수 있고 연결 상태가 일관되게 유지됩니다.
</details>


## 변하영
<details>
  <summary>TCP에서 ISN을 난수로 설정하는 이유는 무엇인가요?</summary>
보안과 연결 구분 때문입니다. 일정한 패턴을 가진 ISN을 사용하면 공격자가 추측하여 세션을 탈취할 수 있고, 이전 연결과 혼동될 가능성이 있습니다. 난수를 사용하면 이러한 문제를 방지할 수 있습니다.
</details>
<br>
<details>
  <summary>SYN Flooding 공격이 발생하면 어떤 문제가 생기나요?</summary>
공격자는 다수의 SYN 패킷을 보내 서버가 SYN-ACK 응답을 보내도록 유도하지만, ACK를 보내지 않아 서버가 리소스를 소모하게 만듭니다. 결국 서버가 더 이상 정상적인 요청을 처리할 수 없어 DoS 상태가 됩니다.
</details>
<br>
<details>
  <summary>SYN Flooding을 방어하는 방법에는 무엇이 있나요?</summary>
SYN Cookie를 사용하여 서버가 연결 정보를 저장하지 않고도 검증할 수 있도록 하거나, 백로그 큐 크기를 조정하여 더 많은 요청을 수용할 수 있도록 설정하는 방법이 있습니다
</details>
<br>
<details>
  <summary>만약 TCP에서 4-Way Handshake가 아니라 2-Way Handshake로 종료하면 어떤 문제가 발생할까요?</summary>
클라이언트가 FIN을 보내고 서버가 ACK만 보낸 상태에서 바로 연결을 닫으면, 서버가 데이터를 아직 보내지 않았더라도 클라이언트는 더 이상 받을 수 없습니다. 이는 데이터 유실을 초래할 수 있습니다.
</details>
<br>
<details>
  <summary>TCP에서 Half-Close가 필요한 이유는 무엇인가요?</summary>
양방향 스트림에서 한쪽만 데이터 전송을 종료할 필요가 있을 때 사용합니다. 예를 들어, 클라이언트가 데이터를 다 보냈지만 서버는 계속 데이터를 보내야 하는 경우, Half-Close를 사용하여 일방적인 종료를 처리할 수 있습니다.
</details>
<br>

## 박상윤
<details>
  <summary>TCP 3-way handshake 과정에서 서버가 SYN을 받은 후 보내는 응답은 무엇인가요? 설명과 함께 답해주세요.</summary>
서버는 클라이언트의 SYN 요청을 수락하면서, SYN + ACK 패킷을 보냅니다.

SYN: 서버도 클라이언트에게 연결을 요청하는 의미입니다.
ACK: 클라이언트가 보낸 SYN을 확인했다는 응답입니다.
이 패킷을 보낸 후 서버는 SYN_RECEIVED 상태가 됩니다.
서버가 SYN+ACK를 보냄으로써, 서로 ISN(Initial Sequence Number)을 동기화하는 과정이 포함됩니다.
</details>
<br>
<details>
  <summary>4-way handshake 과정에서 TIME_WAIT 상태는 어떤 역할을 하나요?</summary>
TIME_WAIT 상태는 연결이 완전하게 종료되기 전에 일정 시간 동안 해당 소켓을 유지하는 단계입니다.

마지막 ACK가 유실될 경우, 상대방이 FIN을 재전송할 수 있도록 대비하는 역할을 합니다.
또한, 지연된 패킷이 새로운 연결에 혼동을 주는 것을 방지합니다.
TIME_WAIT은 보통 2MSL(Maximum Segment Lifetime, 최대 세그먼트 생존 시간) 동안 유지됩니다.
이 과정은 데이터 유실 방지와 포트 재사용 충돌 방지라는 중요한 역할을 합니다.

</details>
<br>

<details>
  <summary>3-way handshake가 패킷 유실 및 재전송 상황에서도 신뢰성을 보장할 수 있는 이유는?</summary>
ISN 동기화
서로의 초기 시퀀스 번호(ISN)를 주고받아 데이터 순서를 보장합니다.
패킷 손실 감지 및 재전송
클라이언트는 SYN을 보낸 후, 일정 시간 응답이 없으면 재전송합니다.
서버도 SYN-ACK을 보낸 후, ACK 응답이 없으면 재전송합니다.
양방향 확인
클라이언트와 서버 모두 상대방의 상태를 명확히 인지하고 연결을 설정합니다.
이런 과정을 통해 패킷 손실이나 순서 꼬임을 방지하고, 신뢰성 있는 연결을 보장할 수 있습니다.
</details>

<br>
<details>
  <summary>4-way handshake 과정에서 수신자가 FIN을 받은 후, 바로 FIN을 보내지 않고 CLOSE_WAIT 상태에서 대기하는 이유는 무엇인가요?</summary>
수신자는 클라이언트로부터 FIN을 받았다고 해서 바로 연결을 닫을 수는 없습니다.
왜냐하면 아직 수신자가 전송해야 할 데이터가 남아있을 수 있기 때문입니다.
이때 수신자는 먼저 ACK를 보내고 CLOSE_WAIT 상태로 들어가, 내부적으로 남은 데이터를 모두 처리한 후에 자신도 FIN을 보냅니다.
이 과정이 없다면, 송신자는 데이터를 모두 받지 못한 상태에서 연결이 끊기는 문제가 발생할 수 있습니다.

즉, 수신자가 자신의 전송 데이터를 마무리할 시간을 벌기 위해 CLOSE_WAIT 상태가 필요합니다.
</details>
<br>

<details>
  <summary>4-way handshake 마지막 단계에서 송신자가 FIN에 대한 ACK를 보낸 후 바로 연결을 닫지 않고, TIME_WAIT 상태로 잠시 대기하는 이유는 무엇인가요?</summary>
TIME_WAIT 상태는 두 가지 중요한 이유 때문에 필요합니다.

패킷 지연 및 재전송 대비
네트워크 상황에 따라 FIN에 대한 최종 ACK가 유실될 가능성이 있습니다.
이 경우, 수신자는 FIN을 재전송하게 되는데, 송신자가 TIME_WAIT 상태에 있어야 이 재전송 FIN을 다시 처리할 수 있습니다.
패킷 혼동 방지
네트워크 상에 지연된 패킷이 남아 있다가, 동일한 포트로 새 연결이 바로 시작되면, 이전 연결의 패킷과 혼동될 수 있습니다.
TIME_WAIT 동안 기다리면, 이런 지연 패킷이 모두 소멸되므로 새로운 연결과 충돌을 방지할 수 있습니다.
즉, TIME_WAIT은 데이터 유실 방지 및 새로운 연결 충돌 방지라는 두 가지 이유로 반드시 필요한 과정입니다.
</details>