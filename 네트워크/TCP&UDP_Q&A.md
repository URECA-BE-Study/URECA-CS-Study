## 변하영
<details>
  <summary>TCP에서 흐름 제어와 혼잡 제어의 차이점은 무엇인가요?</summary>
  흐름 제어는 송신 측과 수신 측 간의 속도 차이를 조절하고 혼잡 제어는 네트워크에서 혼잡이 발생하지 않도록 전송 속도를 조절합니다. 흐름 제어 기법에는 Sliding window, stop and wait가 있고 혼잡 제어 기법에는 AIMD, Slow start, Fast Recovery 등이 있습니다.   
</details>

<details>
  <summary>“Slow Start”는 어떤 문제를 해결하려는 기법인가요? 그리고 이 방식이 항상 효율적일까요?</summary>
low Start는 네트워크가 감당할 수 있는 전송 속도를 자동으로 조절하는 기법입니다.

네트워크에서 초기에 너무 많은 데이터를 한꺼번에 전송하면 라우터나 중간 네트워크 장비가 과부하에 걸릴 수 있습니다. Slow Start는 전송 윈도우 크기를 작게 시작한 뒤, ACK을 받을 때마다 지수적으로 증가시키면서 네트워크가 감당할 수 있는 속도를 찾도록 합니다.

하지만 이 방식이 항상 효율적인 것은 아닙니다.

첫 번째 문제는, 초기에 너무 느리게 시작한다는 점입니다. 예를 들어, 처음에는 작은 윈도우 크기로 시작하기 때문에, 고속 네트워크 환경에서는 데이터 전송 속도가 제한될 수 있습니다.

두 번째 문제는, 혼잡이 발생하면 다시 윈도우 크기를 낮춰야 한다는 점입니다.

그래서 TCP Reno, TCP Cubic 같은 개선된 혼잡 제어 알고리즘은 Slow Start 이후에도 네트워크 상태에 따라 윈도우 크기를 더 효율적으로 조절할 수 있도록 설계되었습니다.
</details>

<details>
  <summary>ACK, SYN 같은 정보는 어떻게 전달하는 것일까요?</summary>
  이러한 정보는 TCP 패킷의 헤더 필드에 포함되어 전달됩니다.
  TCP 헤더에는 SYN, ACK 등의 플래그 비트(flag bit) 가 존재하며, 특정한 값을 설정함으로써 패킷의 역할을 결정합니다.
  예를 들어, SYN = 1로 설정된 패킷은 연결을 요청하는 패킷이고, ACK = 1로 설정된 패킷은 이전 패킷을 정상적으로 수신했음을 확인하는 응답 패킷입니다.
  또한, TCP는 Sequence Number와 Acknowledgment Number (ACK) 값을 함께 사용하여 데이터가 순서대로 도착했는지도 확인합니다.
</details>

<details>
  <summary>2-Way Handshake를 하지 않는 이유에 대해 설명해 주세요.</summary>
  TCP는 양방향성 연결이기 때문에 클라이언트에서 서버에게 자신의 존재를 알리고 패킷을 보낼 수 있는 것처럼 서버에서도 클라이언트에게 자신의 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내야 하기 때문입니다.
</details>

<details>
  <summary>왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것일까요?</summary>
  TCP는 신뢰성 있는 통신을 보장하기 위해, 연결 종료 후에도 일정 시간 동안 TIME_WAIT 상태를 유지합니다. 그 이유는 지연된 패킷이 네트워크에 남아 있을 가능성이 있기 때문입니다. 만약 연결을 바로 닫아버리면, 이전 연결의 패킷이 새로운 연결과 충돌할 수도 있습니다.
  따라서, TCP는 일정 시간 동안 TIME_WAIT 상태에서 대기하며 모든 패킷이 네트워크에서 사라졌음을 보장한 후에 소켓을 완전히 닫습니다.
</details>

<details>
  <summary>TCP의 4-Way Handshake 중 서버가 FIN을 보내고 클라이언트가 ACK를 보내지 않으면 어떤 현상이 발생하나요?</summary>
  서버가 FIN 패킷을 보냈다는 것은 더 이상 데이터를 보낼 필요가 없다는 의미입니다. 이때 클라이언트가 ACK 패킷을 보내지 않는다면, 서버는 FIN_WAIT_2 상태에서 일정 시간 동안 대기하게 됩니다.
  클라이언트가 정상적으로 ACK을 보내면 연결이 정상 종료되지만, 만약 클라이언트가 ACK을 보내지 않거나 강제 종료되면, 서버는 일정 시간이 지나면 Time out을 발생시켜 연결을 강제 종료하게 됩니다.
</details>

<details>
  <summary>빨리 끊어야 할 경우엔, (즉, 4-Way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?</summary>
  만약 빠르게 연결을 종료해야 한다면 RST(Reset) 패킷을 전송하면 됩니다.
  일반적인 4-Way Handshake는 정상적인 종료 과정이지만,
  급하게 종료해야 할 경우, TCP 헤더의 RST 플래그를 1로 설정한 패킷을 보내면 즉시 연결이 끊어집니다.
  예를 들어, 서버가 과부하 상태이거나, 예기치 않은 오류가 발생했을 때 RST 패킷을 보내 연결을 강제 종료할 수 있습니다.
</details>


## 이소원
<details>
  <summary>udp는 어떤 경우에 사용해야 하나요?</summary>

1. 빈번한 서비스 요청이 일어나는 경우
    - DNS의 경우 누군가 DNS 서비스를 요청할 때마다 TCP처럼 Session을 맺고 통신한다면 속도도 느리고, 서버 리소스도 엄청나게 소모될 것이다.
    - NMS(Network Management Server)가 5분에 한번씩 장비 상태를 점검하기 위해 정보를 읽어오는데 수백, 수천대의 장비와 Session을 맺어야 한다면 문제가 발생할 것이다.
2. 재전송을 하면 안되는 서비스인 경우
    - 대표적으로 RTP(Real-time Transport Protocol) : 오디오, 비디오 스트리밍과 같은 실시간 데이터를 전송하기 위한 프로토콜
    - 전화를 하고 있다 다고 가정
        - "여","보","세","요"라는 4개의 데이터를 전송했는데, "세"를 못받았다고 다시 보내달라고 하면 "여보요세"가 될 것
        - 이럴 때는 그냥 "여보X요"로 전달하는게 나은 상황
3. Multicast 서비스의 경우
    - 1:N으로 통신하는 방식에서 한 사람이 데이터를 받지 못했다고 재전송을 요청한다고 가정
    - 제대로 받은 사람들도 해당 데이터를 다시 받아서 처리해야 한다는 문제점이 발생할 수 있기 때문에 UDP를 사용   
</details>

<details>
    <summary>TCP에서 말하는 신뢰성 3가지가 뭔가요?</summary>
    안정적으로 전송, 순서대로 전송,에러 없이 전송
</details>

<details>
    <summary>2-way handshaking을 하지 않는 이유는 뭘까요?</summary>
    신뢰성 부족으로 인해 패킷 손실 및 연결 문제가 발생할 수 있기 때문입니다.

2-way handshaking을 하게 되면 클라이언트가 서버에 syn을 전송해서 연결 요청을 하고,서버가 다시 클라이언트에게 syn + ack를 전송하여 연결을 승인 및 응답을 하는데
이러한 상황에서 서버는 클라이언트가 syn+ack 패킷을 받았는지 확인 할 수 없어 중간에 패킷이 손실되면 정상적으로 수집되지 않아, 전송 및 응답의 신뢰성이 보장되지 않습니다.
</details>

<details>
    <summary>두 호스트가 동시에 서로에게 TCP 연결을 시도하면, 연결이 가능할까요?</summary>
    가능합니다. 이때 동시 개방 방식으로 연결됩니다.

📌 일반적인 TCP 연결 흐름 (한쪽이 먼저 요청)

1. 클라이언트 → 서버 : SYN 전송 (연결 요청)
2. 서버 → 클라이언트 : SYN+ACK 응답
3. 클라이언트 → 서버 : ACK 전송 (연결 확정)

📌 동시 연결 요청(Simultaneous Open) 시나리오

1. 호스트 A → 호스트 B : SYN 전송
2. 호스트 B → 호스트 A : SYN 전송 (동시에 요청)
3. 호스트 A → 호스트 B : SYN+ACK 전송
4. 호스트 B → 호스트 A : SYN+ACK 전송
5. 서로의 ACK를 받은 후 연결 완료

즉, 동시 연결 요청 시, 양쪽에서 SYN을 전송한 후 각자 ACK를 주고받으며 연결이 성립됩니다.
</details>

<details>
    <summary>UDP의 속도와 네트워크 부하가 적으면서 TCP의 신뢰성을 가진 데이터를 전송하고 싶다면 어떻게 할 수 있을까요?</summary>
    시퀀스 번호 등을 정의하여 서버와 클라이언트 간에 패킷 유실에 대한 대처방법을 상호 정의한다면 UDP 기반의 신뢰성 있는 프로토콜을 만들 수 있습니다. (QUIC)
</details>

<details>
    <summary>네트워크를 안정적으로 운영하기 위해 어떤 전략을 사용하나요?</summary>
    혼잡 제어 - AIMD
</details>

<details>
    <summary>자율 주행, 실시간 스트리밍 등 네트워크가 혼잡해지기전에 최대한 빠르게 활용해야하는 상황에서는 tcp보다는 udp를 많이 사용하여 빠른 데이터 전송기법을 통해 지연을 최소화 합니다. 그렇다면 빠르게 데이터를 보내야하는 상황이라면 항상 udp를 사용하는 것이 더 좋은 선택일까요?</summary>
    아닙니다. udp는 빠르지만 패킷 손실이나 순서 보장, 오류 제어 기능이 부족하다는 단점이 있습니다. 따라서 데이터의 신뢰성이 중요한 금융 거래(계좌 송금, 카드 결제 등)나 순서 보장이 필수인 파일 다운로드와 같은 상황에서는 tcp를 사용해야 합니다.
</details>

## 박상윤
<details>
    <summary>TCP에서 흐름 제어와 혼잡 제어는 각각 어떤 역할을 하는지 설명해 주세요.</summary>
흐름 제어는 송신부와 수신부 간의 데이터 처리 속도 차이를 조절하여 데이터 손실을 방지하는 기법입니다. 혼잡 제어는 네트워크 내에서 패킷이 과도하게 증가하여 혼잡이 발생하는 것을 방지하기 위해 송신 속도를 조절하는 기법입니다.
</details>

<details>
    <summary>슬라이딩 윈도우(Sliding Window) 방식이 정지 대기(Stop-and-Wait) 방식보다 효율적인 이유는 무엇인가요?</summary>
정지 대기 방식은 한 번에 하나의 패킷을 보내고, ACK를 받은 후에야 다음 패킷을 보낼 수 있어 비효율적입니다. 반면, 슬라이딩 윈도우 방식은 일정한 윈도우 크기 내에서 여러 개의 패킷을 연속적으로 전송할 수 있어 송신 대역폭을 더 효율적으로 활용할 수 있습니다.
</details>

<details>
    <summary>Go-Back-N ARQ와 Selective-Repeat ARQ 방식의 차이점을 설명해 주세요.</summary>
Go-Back-N ARQ는 패킷이 손실되었을 경우 해당 패킷 이후의 모든 패킷을 다시 전송하는 방식입니다. 반면, Selective-Repeat ARQ는 손실된 패킷만 재전송하여 불필요한 중복 전송을 줄일 수 있습니다. 하지만 Selective-Repeat 방식은 수신부에서 패킷을 정렬해야 하는 추가적인 부담이 있습니다.
</details>

<details>
    <summary>TCP Reno와 TCP Tahoe의 차이점은 무엇인가요?</summary>
TCP Tahoe는 혼잡이 발생하면 윈도우 크기를 1로 초기화하고, 다시 Slow Start 단계로 돌아갑니다. 반면, TCP Reno는 3개의 Duplicate ACK가 발생하면 혼잡 윈도우 크기를 절반으로 줄이고, 타임아웃이 발생하면 TCP Tahoe처럼 윈도우 크기를 1로 초기화합니다.
</details>

<details>
    <summary>TCP에서 Fast Retransmit과 Fast Recovery의 역할을 설명해 주세요.</summary>
Fast Retransmit은 Duplicate ACK가 3번 발생하는 경우 해당 시점의 윈도우 크기를 1/2로 줄입니다. 그뒤, ACK 메시지를 받는 경우 다시 윈도우 크기를 늘리는 방식입니다. 

Fast Recovery는 혼잡이 발생한 후 Slow Start로 돌아가지 않고 혼잡 윈도우 크기를 절반으로 줄인 후 선형적으로 증가시키는 방식으로, 네트워크의 회복 속도를 높이는 역할을 합니다.
</details>

<details>
    <summary>TCP의 혼잡 제어 방식에서 AIMD(Additive Increase Multiplicative Decrease)는 어떻게 동작하나요?</summary>
AIMD는 송신 윈도우 크기를 천천히 증가시키면서 네트워크의 상태를 점진적으로 확인하는 방식입니다. 네트워크가 정상적으로 동작하면 송신 윈도우 크기를 1씩 선형적으로 증가시키지만, 혼잡이 감지되면 현재 윈도우 크기의 50%로 감소시켜 네트워크 혼잡을 방지합니다.
</details>

<details>
    <summary>흐름 제어 방법 중 슬라이딩 윈도우 방법의 윈도우 크기는 언제 정해지나요?</summary>
3-way handshaking 과정에서 정해집니다.
</details>

## 신예지

<details>
    <summary>TCP에서 하는 전송 제어 기법에는 무엇이 있고, 각각에 대해 설명해주세요</summary>
- 흐름 제어(Flow control): 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지
- 오류 제어(Error Control): 데이터가 유실되거나 잘못된 데이터가 수신되었을 경우 대처하는 방법
- 혼잡 제어(Congestion control): 네트워크 내의 패킷 수가 과도하게 증가하지 않도록 방지
</details>

<details>
    <summary>TCP의 오류 제어 기법에서 오류를 알 수 있는 방법 3가지를 설명해주세요</summary>
- 송신 측이 ACK를 받지 못함(송신 측이 보낸 데이터가 유실되거나 수신 측이 보낸 ACK 데이터가 유실된 경우)
- 중복된 ACK는 받는 경우
- 수신 측이 NACK(부정 응답)을 보내는 경우
</details>

<details>
    <summary>QUIC 의 장점을 설명해주세요</summary>
UDP 보다 안전하고 TCP 보다 빠르다
    <details>
        <summary>왜?</summary>
        QUIC은 사전에 핸드셰이크를 완료할 필요 없이 연결 시작 시에 클라이언트가 바로 서버에 데이터를 보낼 수 있도록 함
    </details>
</details>

<details>
    <summary>복습) TCP 3-way-handshake에서 ISN(Initial Sequence Number)을 0부터 시작하지 않고 랜덤한 숫자로 설정하는 이유를 설명해주세요</summary>
Connection을 맺을 때 사용하는 포트(port)는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다.

따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다.

서버 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 number가 전송된다면 이전의 connection으로부터 오는 패킷으로 인식할 수 있다. 이러한 문제가 발생할 가능성을 줄이기 위해서 난수로 ISN을 설정하는 것이다.
</details>

<details>
    <summary>TCP 4-way-handshake에서 클라이언트가 서버로부터 FIN을 받고 다시 서버에서 ACK를 보낸 후 일정 시간 대기한 후 CLOSED 가 됩니다. 클라이언트는 왜 일정 시간 후에 연결을 닫을까요?</summary>
    지연 패킷이 발생할 경우를 대비

- 네트워크에서 오래된 패킷이 지연되거나 재전송될 가능성이 있음
- TIME_WAIT 동안 기다림으로써 이전 연결에서 유실되거나 늦게 도착한 패킷이 현재 연결에 영향을 주지 않도록 함

2. 두 장치가 연결이 닫혔는지 확인하기 위해서

- TCP는 완전한 양방향 종료를 보장해야 함
- 클라이언트가 서버의 FIN에 대한 ACK를 보냈지만 이 ACK가 유실될 수도 있음
- 이 경우, 서버는 FIN을 다시 보낼 수 있기 때문에 클라이언트가 일정 시간 동안 기다리며 재전송된 FIN을 받을 준비를 함
- 일반적으로 2 * MSL(Maximum Segment Lifetime, 최대 세그먼트 수명) 동안 기다림
    - MSL은 네트워크에서 패킷이 살아남을 수 있는 최대 시간으로, 이 시간이 지나면 지연된 패킷이 더 이상 존재하지 않을 것이라 가정하고 연결을 닫음
</details>

## 김수훈
<details>
    <summary>TCP와 UDP에서 패킷을 교환하는 방식에 대해 각각 설명하세요.</summary>
TCP 방식에서는 가상 회선 방식을 사용합니다. 

가상 회선 방식은 데이터를 주고받기 전에 패킷을 전송할 가상 회선 경로를 설정한 후 패킷을 전송합니다. 이를 통해 패킷의 전송 순서를 보장할 수 있습니다.

UDP 방식에서는 데이터그램 방식을 사용합니다.

데이터그램 방식은 패킷마다 최적의 경로로 전송되는 방식으로, 전송 속도가 더 빨라질 수 있지만 송신부의 패킷 순서와 수신부의 패킷 순서가 달라질 수 있습니다.
</details>

<details>
    <summary>Sequence Number와 ACK Number는 무엇이고, 어떤 기능을 하나요?</summary>
Sequence Number는 데이터의 순서를 나타냅니다. 보통 이전에 보냈던 Sequence Number에 이전에 보냈던 데이터의 바이트 수만큼 증가시키며, 처음 생성되는 Sequence Number는 난수입니다. 

ACK Number는 다음에 받아야 할 데이터의 순서를 나타냅니다. 받은 세그먼트의 Sequence Number에 해당 세그먼트의 데이터 바이트 수를 더한 값을 ACK Number로 사용합니다.

Sequence Number와 ACK Number는 패킷의 순서를 재조립해 순서에 맞게 데이터가 전달되도록 돕고, 데이터가 유실됐는지 확인해 재전송을 요구하는 기능을 합니다.
</details>

<details>
    <summary>DNS는 일반적으로 UDP 프로토콜을 사용하는데, 그 이유가 무엇일지 고민하고 설명해주세요.</summary>
DNS가 UDP 프로토콜을 이용하는 이유는 속도를 중요시하기 때문입니다. DNS는 도메인 네임을 IP 주소로 변환해 줍니다. 따라서 전 세계 많은 클라이언트에서 요청이 들어오고 빠르게 응답하는 것이 중요합니다. 또한 한 번의 응답이 제대로 전달된다면 더 이상의 추가적인 데이터를 필요로 하지 않기 때문에 UDP를 이용합니다.
</details>

<details>
    <summary>4-way handshake 과정 중에 FIN을 받은 서버는 왜 바로 FIN 패킷을 보내지 않고 ACK을 보낸 후, FIN 패킷을 보내나요?</summary>
    클라이언트가 FIN 패킷이 잘 도착했는지에 대한 응답을 기다리고 있기 때문입니다. 만약 서버가 ACK 패킷을 우선적으로 보내지 않고 모든 프로세스를 마친 후에 FIN 패킷만 바로 보내게 된다면, 클라이언트는 FIN 패킷이 유실된 줄 알고 FIN 패킷을 지속적으로 보낼 것입니다. 따라서 패킷을 받았다는 응답을 바로 하기 위해 ACK 패킷을 보낸 후에 프로세스가 종료된 후 연결을 끊는 FIN 패킷을 보내는 것입니다.
</details>

<details>
    <summary>UDP에는 3-way handshake가 없나요?</summary>
네, 없습니다. UDP는 비연결지향형 프로토콜로 사용되기 때문에 일방향적인 통신을 제공하고 있어 두 종단 간 연결을 하는 3-way handshake는 필요하지 않습니다.
</details>
